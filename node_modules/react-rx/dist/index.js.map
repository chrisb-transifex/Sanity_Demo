{"version":3,"file":"index.js","sources":["../src/useObservable.ts","../src/useObservableEvent.ts"],"sourcesContent":["import {useEffect, useMemo, useRef, useSyncExternalStore} from 'react'\nimport {\n  catchError,\n  finalize,\n  type Observable,\n  type ObservedValueOf,\n  of,\n  share,\n  type Subscription,\n} from 'rxjs'\nimport {map, tap} from 'rxjs/operators'\n\nfunction getValue<T>(value: T): T extends () => infer U ? U : T {\n  return typeof value === 'function' ? value() : value\n}\n\ninterface CacheRecord<T> {\n  subscription: Subscription\n  observable: Observable<void>\n  snapshot: T\n  error?: unknown\n}\n\nconst cache = new WeakMap<Observable<any>, CacheRecord<any>>()\n\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>>(\n  observable: ObservableType,\n  initialValue: ObservedValueOf<ObservableType> | (() => ObservedValueOf<ObservableType>),\n): ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>>(\n  observable: ObservableType,\n): undefined | ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>, InitialValue>(\n  observable: ObservableType,\n  initialValue: InitialValue,\n): InitialValue | ObservedValueOf<ObservableType>\n/** @public */\nexport function useObservable<ObservableType extends Observable<any>, InitialValue>(\n  observable: ObservableType,\n  initialValue?: InitialValue | (() => InitialValue),\n): InitialValue | ObservedValueOf<ObservableType> {\n  /**\n   * Store the initialValue in a ref, as we don't want a changed `initialValue` to trigger a re-subscription.\n   * But we also don't want the initialValue to be stale if the observable changes.\n   */\n  const initialValueRef = useRef(getValue(initialValue) as ObservedValueOf<ObservableType>)\n\n  /**\n   * Ensures that the initialValue is always up-to-date in case the observable changes.\n   */\n  useEffect(() => {\n    initialValueRef.current = getValue(initialValue) as ObservedValueOf<ObservableType>\n  }, [initialValue])\n\n  const store = useMemo(() => {\n    if (!cache.has(observable)) {\n      const entry: Partial<CacheRecord<ObservedValueOf<ObservableType>>> = {\n        snapshot: initialValueRef.current,\n      }\n      entry.observable = observable.pipe(\n        map((value) => ({snapshot: value, error: undefined})),\n        catchError((error) => of({snapshot: undefined, error})),\n        tap(({snapshot, error}) => {\n          entry.snapshot = snapshot\n          entry.error = error\n        }),\n        // Note: any value or error emitted by the provided observable will be mapped to the cache entry's mutable state\n        // and the observable is thereafter only used as a notifier to call `onStoreChange`, hence the `void` return type.\n        map((value) => void value),\n        // Ensure that the cache entry is deleted when the observable completes or errors.\n        finalize(() => cache.delete(observable)),\n        share(),\n      )\n\n      // Eagerly subscribe to sync set `entry.currentValue` to what the observable returns, and keep the observable alive until the component unmounts.\n      entry.subscription = entry.observable.subscribe()\n\n      cache.set(observable, entry as CacheRecord<ObservedValueOf<ObservableType>>)\n    }\n    // eslint-disable-next-line @typescript-eslint/no-non-null-assertion\n    const instance = cache.get(observable)!\n    if (instance.subscription.closed) {\n      instance.subscription = instance.observable.subscribe()\n    }\n\n    return {\n      subscribe: (onStoreChange: () => void) => {\n        const subscription = instance.observable.subscribe(onStoreChange)\n        instance.subscription.unsubscribe()\n        return () => {\n          subscription.unsubscribe()\n        }\n      },\n      getSnapshot: () => {\n        if (instance.error) {\n          throw instance.error\n        }\n        return instance.snapshot\n      },\n    }\n  }, [observable])\n\n  return useSyncExternalStore<ObservedValueOf<ObservableType>>(\n    store.subscribe,\n    store.getSnapshot,\n    typeof initialValueRef.current === 'undefined' ? undefined : () => initialValueRef.current,\n  )\n}\n","import {observableCallback} from 'observable-callback'\nimport {useCallback, useEffect, useInsertionEffect, useRef, useState} from 'react'\nimport {type Observable} from 'rxjs'\n\n/** @public */\nexport function useObservableEvent<T, U>(\n  fn: (arg: Observable<T>) => Observable<U>,\n): (arg: T) => void {\n  const [[calls$, call]] = useState(() => observableCallback<T>())\n\n  const callback = useEffectEvent(fn)\n\n  useEffect(() => {\n    const subscription = calls$.pipe(callback).subscribe()\n    return () => subscription.unsubscribe()\n  }, [callback, calls$])\n\n  return call\n}\n\n/**\n * This is a ponyfill of the upcoming `useEffectEvent` hook that'll arrive in React 19.\n * https://19.react.dev/learn/separating-events-from-effects#declaring-an-effect-event\n * To learn more about the ponyfill itself, see: https://blog.bitsrc.io/a-look-inside-the-useevent-polyfill-from-the-new-react-docs-d1c4739e8072\n */\nfunction useEffectEvent<\n  const T extends (\n    ...args: // eslint-disable-next-line @typescript-eslint/no-explicit-any\n    any[]\n  ) => void,\n>(fn: T): T {\n  const ref = useRef<T | null>(null)\n  useInsertionEffect(() => {\n    ref.current = fn\n  }, [fn])\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return useCallback((...args: any[]) => {\n    const f = ref.current!\n    return f(...args)\n  }, []) as T\n}\n"],"names":[],"mappings":";;;;AAYA,SAAS,SAAY,OAA2C;AAC9D,SAAO,OAAO,SAAU,aAAa,MAAA,IAAU;AACjD;AASA,MAAM,4BAAY;AAiBF,SAAA,cACd,YACA,cACgD;AAKhD,QAAM,kBAAkB,OAAO,SAAS,YAAY,CAAoC;AAKxF,YAAU,MAAM;AACE,oBAAA,UAAU,SAAS,YAAY;AAAA,EAAA,GAC9C,CAAC,YAAY,CAAC;AAEX,QAAA,QAAQ,QAAQ,MAAM;AAC1B,QAAI,CAAC,MAAM,IAAI,UAAU,GAAG;AAC1B,YAAM,QAA+D;AAAA,QACnE,UAAU,gBAAgB;AAAA,MAAA;AAE5B,YAAM,aAAa,WAAW;AAAA,QAC5B,IAAI,CAAC,WAAW,EAAC,UAAU,OAAO,OAAO,SAAW;AAAA,QACpD,WAAW,CAAC,UAAU,GAAG,EAAC,UAAU,QAAW,MAAK,CAAC,CAAC;AAAA,QACtD,IAAI,CAAC,EAAC,UAAU,YAAW;AACnB,gBAAA,WAAW,UACjB,MAAM,QAAQ;AAAA,QAAA,CACf;AAAA;AAAA;AAAA,QAGD,IAAI,CAAC,UAAO;AAAA,QAAA,CAAa;AAAA;AAAA,QAEzB,SAAS,MAAM,MAAM,OAAO,UAAU,CAAC;AAAA,QACvC,MAAM;AAAA,MACR,GAGA,MAAM,eAAe,MAAM,WAAW,aAEtC,MAAM,IAAI,YAAY,KAAqD;AAAA,IAC7E;AAEM,UAAA,WAAW,MAAM,IAAI,UAAU;AACjC,WAAA,SAAS,aAAa,WACxB,SAAS,eAAe,SAAS,WAAW,cAGvC;AAAA,MACL,WAAW,CAAC,kBAA8B;AACxC,cAAM,eAAe,SAAS,WAAW,UAAU,aAAa;AACvD,eAAA,SAAA,aAAa,YAAY,GAC3B,MAAM;AACX,uBAAa,YAAY;AAAA,QAAA;AAAA,MAE7B;AAAA,MACA,aAAa,MAAM;AACjB,YAAI,SAAS;AACX,gBAAM,SAAS;AAEjB,eAAO,SAAS;AAAA,MAClB;AAAA,IAAA;AAAA,EACF,GACC,CAAC,UAAU,CAAC;AAER,SAAA;AAAA,IACL,MAAM;AAAA,IACN,MAAM;AAAA,IACN,OAAO,gBAAgB,UAAY,MAAc,SAAY,MAAM,gBAAgB;AAAA,EAAA;AAEvF;ACzGO,SAAS,mBACd,IACkB;AAClB,QAAM,CAAC,CAAC,QAAQ,IAAI,CAAC,IAAI,SAAS,MAAM,mBAAsB,CAAC,GAEzD,WAAW,eAAe,EAAE;AAElC,SAAA,UAAU,MAAM;AACd,UAAM,eAAe,OAAO,KAAK,QAAQ,EAAE,UAAU;AAC9C,WAAA,MAAM,aAAa;EACzB,GAAA,CAAC,UAAU,MAAM,CAAC,GAEd;AACT;AAOA,SAAS,eAKP,IAAU;AACJ,QAAA,MAAM,OAAiB,IAAI;AACjC,SAAA,mBAAmB,MAAM;AACvB,QAAI,UAAU;AAAA,KACb,CAAC,EAAE,CAAC,GAEA,YAAY,IAAI,SAAgB;AACrC,UAAM,IAAI,IAAI;AACP,WAAA,EAAE,GAAG,IAAI;AAAA,EAClB,GAAG,CAAE,CAAA;AACP;"}