import { useRef, useEffect, useMemo, useSyncExternalStore, useState, useInsertionEffect, useCallback } from "react";
import { catchError, of, finalize, share } from "rxjs";
import { map, tap } from "rxjs/operators";
import { observableCallback } from "observable-callback";
function getValue(value) {
  return typeof value == "function" ? value() : value;
}
const cache = /* @__PURE__ */ new WeakMap();
function useObservable(observable, initialValue) {
  const initialValueRef = useRef(getValue(initialValue));
  useEffect(() => {
    initialValueRef.current = getValue(initialValue);
  }, [initialValue]);
  const store = useMemo(() => {
    if (!cache.has(observable)) {
      const entry = {
        snapshot: initialValueRef.current
      };
      entry.observable = observable.pipe(
        map((value) => ({ snapshot: value, error: void 0 })),
        catchError((error) => of({ snapshot: void 0, error })),
        tap(({ snapshot, error }) => {
          entry.snapshot = snapshot, entry.error = error;
        }),
        // Note: any value or error emitted by the provided observable will be mapped to the cache entry's mutable state
        // and the observable is thereafter only used as a notifier to call `onStoreChange`, hence the `void` return type.
        map((value) => {
        }),
        // Ensure that the cache entry is deleted when the observable completes or errors.
        finalize(() => cache.delete(observable)),
        share()
      ), entry.subscription = entry.observable.subscribe(), cache.set(observable, entry);
    }
    const instance = cache.get(observable);
    return instance.subscription.closed && (instance.subscription = instance.observable.subscribe()), {
      subscribe: (onStoreChange) => {
        const subscription = instance.observable.subscribe(onStoreChange);
        return instance.subscription.unsubscribe(), () => {
          subscription.unsubscribe();
        };
      },
      getSnapshot: () => {
        if (instance.error)
          throw instance.error;
        return instance.snapshot;
      }
    };
  }, [observable]);
  return useSyncExternalStore(
    store.subscribe,
    store.getSnapshot,
    typeof initialValueRef.current > "u" ? void 0 : () => initialValueRef.current
  );
}
function useObservableEvent(fn) {
  const [[calls$, call]] = useState(() => observableCallback()), callback = useEffectEvent(fn);
  return useEffect(() => {
    const subscription = calls$.pipe(callback).subscribe();
    return () => subscription.unsubscribe();
  }, [callback, calls$]), call;
}
function useEffectEvent(fn) {
  const ref = useRef(null);
  return useInsertionEffect(() => {
    ref.current = fn;
  }, [fn]), useCallback((...args) => {
    const f = ref.current;
    return f(...args);
  }, []);
}
export {
  useObservable,
  useObservableEvent
};
//# sourceMappingURL=index.js.map
