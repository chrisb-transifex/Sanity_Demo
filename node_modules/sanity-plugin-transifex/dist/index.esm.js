import { baseDocumentLevelConfig, legacyDocumentLevelConfig as legacyDocumentLevelConfig$1, baseFieldLevelConfig } from 'sanity-translations-tab';
export { BaseDocumentDeserializer, BaseDocumentMerger, BaseDocumentSerializer, TranslationsTab, customSerializers, defaultStopTypes, documentLevelPatch, fieldLevelPatch, findLatestDraft, legacyDocumentLevelPatch } from 'sanity-translations-tab';
const baseTransifexUrl = "https://rest.api.transifex.com";
const getHeaders = secrets => ({
  Authorization: "Bearer ".concat(secrets == null ? void 0 : secrets.token),
  "Content-Type": "application/vnd.api+json"
});
const projOrgSlug = secrets => "o:".concat(secrets == null ? void 0 : secrets.organization, ":p:").concat(secrets == null ? void 0 : secrets.project);
const getLocales = async secrets => {
  let locales = [];
  if (secrets) {
    locales = await fetch("".concat(baseTransifexUrl, "/projects/").concat(projOrgSlug(secrets), "/languages"), {
      headers: getHeaders(secrets)
    }).then(res => res.json()).then(res => res.data.map(lang => ({
      enabled: true,
      description: lang.attributes.name,
      localeId: lang.attributes.code
    })));
  }
  return locales;
};
const getTranslationTask = async (documentId, secrets) => {
  if (!documentId || !secrets) {
    return {
      taskId: documentId,
      documentId,
      locales: []
    };
  }
  const projectFilter = "filter[project]=".concat(projOrgSlug(secrets));
  const resourceFilter = "filter[resource]=".concat(projOrgSlug(secrets), ":r:").concat(documentId);
  const task = await fetch("".concat(baseTransifexUrl, "/resource_language_stats?").concat(projectFilter, "&").concat(resourceFilter), {
    headers: getHeaders(secrets)
  }).then(res => {
    if (res.ok) {
      return res.json();
    } else if (res.status === 404) {
      return {
        data: []
      };
    }
    throw Error("Failed to retrieve tasks from Transifex. Status: ".concat(res.status));
  }).then(res => ({
    taskId: "".concat(projOrgSlug(secrets), ":r:").concat(documentId),
    documentId,
    locales: res.data.map(locale => ({
      localeId: locale.relationships.language.data.id.split(":")[1],
      progress: Math.floor(100 * (locale.attributes.reviewed_strings / parseFloat(locale.attributes.total_strings)))
    }))
  }));
  const locales = await getLocales(secrets);
  const localeIds = locales.map(l => l.localeId);
  const validLocales = task.locales.filter(locale => localeIds.find(id => id === locale.localeId));
  task.locales = validLocales;
  return task;
};
const pollForFileDownloadLocation = async (resourceDownloadUrl, translationDownloadId, headers) => {
  const response = await fetch("".concat(resourceDownloadUrl, "/").concat(translationDownloadId), {
    headers
  });
  if (response.status === 500) {
    console.info("Transifex plugin message: Received 500 for translation download ID ".concat(translationDownloadId, ". Trying to reconnect..."));
    await new Promise(resolve => setTimeout(resolve, 3e3));
    return pollForFileDownloadLocation(resourceDownloadUrl, translationDownloadId, headers);
  } else if (response.redirected) {
    console.info("Transifex plugin message: Received redirect for translation download ID ".concat(translationDownloadId, ". Following redirect now for file download."));
    return response.url;
  } else if (response.status === 200) {
    console.info("Transifex plugin message: Requested download location for translation download ID ".concat(translationDownloadId, ". Location is still pending, trying again."));
    await new Promise(resolve => setTimeout(resolve, 3e3));
    return pollForFileDownloadLocation(resourceDownloadUrl, translationDownloadId, headers);
  }
  console.error("Transifex plugin message: Requested download location for translation download ID ".concat(translationDownloadId, " but received error code ").concat(response.status, ". Waiting and trying again."));
  await new Promise(resolve => setTimeout(resolve, 3e3));
  return pollForFileDownloadLocation(resourceDownloadUrl, translationDownloadId, headers);
};
const handleFileDownload = url => {
  return fetch(url).then(res => res.text());
};
const getTranslation = async (taskId, localeId, secrets) => {
  const resourceDownloadBody = {
    data: {
      attributes: {
        content_encoding: "text"
      },
      relationships: {
        language: {
          data: {
            id: "l:".concat(localeId),
            type: "languages"
          }
        },
        resource: {
          data: {
            id: taskId,
            type: "resources"
          }
        }
      },
      type: "resource_translations_async_downloads"
    }
  };
  const resourceDownloadUrl = "".concat(baseTransifexUrl, "/resource_translations_async_downloads");
  const translationDownloadId = await fetch(resourceDownloadUrl, {
    headers: getHeaders(secrets),
    method: "POST",
    body: JSON.stringify(resourceDownloadBody)
  }).then(res => res.json()).then(res => res.data.id);
  const headers = getHeaders(secrets);
  const location = await pollForFileDownloadLocation(resourceDownloadUrl, translationDownloadId, headers);
  return handleFileDownload(location);
};
const createResource = (doc, documentId, secrets) => {
  const resourceCreateBody = {
    data: {
      attributes: {
        accept_translations: true,
        name: doc.name,
        slug: documentId
      },
      relationships: {
        i18n_format: {
          data: {
            id: "HTML_FRAGMENT",
            type: "i18n_formats"
          }
        },
        project: {
          data: {
            id: projOrgSlug(secrets),
            type: "projects"
          }
        }
      },
      type: "resources"
    }
  };
  return fetch("".concat(baseTransifexUrl, "/resources"), {
    headers: getHeaders(secrets),
    method: "POST",
    body: JSON.stringify(resourceCreateBody)
  }).then(res => res.json()).then(res => res.data.id);
};
const createTask = async (documentId, document, localeIds, secrets) => {
  let resourceId = await fetch("".concat(baseTransifexUrl, "/resources/").concat(projOrgSlug(secrets), ":r:").concat(documentId), {
    headers: getHeaders(secrets)
  }).then(res => res.json()).then(res => res.data ? res.data.id : null);
  if (!resourceId) {
    resourceId = await createResource(document, documentId, secrets);
  }
  const resourceUploadUrl = "".concat(baseTransifexUrl, "/resource_strings_async_uploads");
  const resourceUploadBody = {
    data: {
      attributes: {
        content: document.content,
        content_encoding: "text"
      },
      relationships: {
        resource: {
          data: {
            id: resourceId,
            type: "resources"
          }
        }
      },
      type: "resource_strings_async_uploads"
    }
  };
  return fetch(resourceUploadUrl, {
    method: "POST",
    body: JSON.stringify(resourceUploadBody),
    headers: getHeaders(secrets)
  }).then(() => getTranslationTask(documentId, secrets));
};
const TransifexAdapter = {
  getLocales,
  getTranslationTask,
  createTask,
  getTranslation
};
const defaultDocumentLevelConfig = {
  ...baseDocumentLevelConfig,
  adapter: TransifexAdapter,
  secretsNamespace: "transifex"
};
const legacyDocumentLevelConfig = {
  ...legacyDocumentLevelConfig$1,
  adapter: TransifexAdapter,
  secretsNamespace: "transifex"
};
const defaultFieldLevelConfig = {
  ...baseFieldLevelConfig,
  adapter: TransifexAdapter,
  secretsNamespace: "transifex"
};
export { TransifexAdapter, defaultDocumentLevelConfig, defaultFieldLevelConfig, legacyDocumentLevelConfig };
//# sourceMappingURL=index.esm.js.map
