import {BaseDocumentDeserializer} from 'sanity-naive-html-serializer'
import {BaseDocumentMerger} from 'sanity-naive-html-serializer'
import {BaseDocumentSerializer} from 'sanity-naive-html-serializer'
import {customSerializers} from 'sanity-naive-html-serializer'
import {defaultStopTypes} from 'sanity-naive-html-serializer'
import {DeserializerRule} from '@sanity/block-tools'
import {JSX as JSX_2} from 'react/jsx-runtime'
import {PortableTextTypeComponent} from '@portabletext/to-html'
import {SanityClient} from 'sanity'
import {SanityDocument} from 'sanity'
import {Schema} from 'sanity'
import {SerializedDocument} from 'sanity-naive-html-serializer'
import {TypedObject} from 'sanity'

export declare interface Adapter {
  getLocales: (secrets: Secrets | null) => Promise<TranslationLocale[]>
  getTranslationTask: (documentId: string, secrets: Secrets | null) => Promise<TranslationTask>
  createTask: (
    taskName: string,
    serializedDocument: SerializedDocument,
    localeIds: string[],
    secrets: Secrets | null,
    workflowUid?: string,
    callbackUrl?: string,
  ) => Promise<TranslationTask>
  getTranslation: (taskid: string, localeId: string, secrets: Secrets | null) => Promise<any | null>
}

export {BaseDocumentDeserializer}

export declare const baseDocumentLevelConfig: {
  exportForTranslation: (
    id: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalStopTypes?: string[] | undefined
          additionalSerializers?: Record<string, PortableTextTypeComponent | undefined> | undefined
        }
      | undefined,
    languageField?: string | undefined,
  ) => Promise<SerializedDocument>
  importTranslation: (
    id: string,
    localeId: string,
    document: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalDeserializers?: Record<string, (value: HTMLElement) => TypedObject> | undefined
          additionalBlockDeserializers?: DeserializerRule[] | undefined
        }
      | undefined,
    languageField?: string | undefined,
    mergeWithTargetLocale?: boolean | undefined,
  ) => Promise<void>
  adapter: Adapter
  secretsNamespace: string
  baseLanguage: string
}

export {BaseDocumentMerger}

export {BaseDocumentSerializer}

export declare const baseFieldLevelConfig: {
  exportForTranslation: (
    id: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalStopTypes?: string[] | undefined
          additionalSerializers?: Record<string, PortableTextTypeComponent | undefined> | undefined
        }
      | undefined,
    languageField?: string | undefined,
  ) => Promise<SerializedDocument>
  importTranslation: (
    id: string,
    localeId: string,
    document: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalDeserializers?: Record<string, (value: HTMLElement) => TypedObject> | undefined
          additionalBlockDeserializers?: DeserializerRule[] | undefined
        }
      | undefined,
    languageField?: string | undefined,
    mergeWithTargetLocale?: boolean | undefined,
  ) => Promise<void>
  adapter: Adapter
  secretsNamespace: string
  baseLanguage: string
}

export {customSerializers}

export {defaultStopTypes}

export declare const documentLevelPatch: (
  documentId: string,
  translatedFields: SanityDocument,
  localeId: string,
  client: SanityClient,
  baseLanguage?: string,
  languageField?: string,
  mergeWithTargetLocale?: boolean,
) => Promise<void>

export declare const DummyAdapter: Adapter

export declare type ExportForTranslation = (
  id: string,
  context: TranslationFunctionContext,
  baseLanguage?: string,
  serializationOptions?: {
    additionalStopTypes?: string[]
    additionalSerializers?: Record<string, PortableTextTypeComponent | undefined>
  },
  languageField?: string,
) => Promise<SerializedDocument>

export declare const fieldLevelPatch: (
  documentId: string,
  translatedFields: SanityDocument,
  localeId: string,
  client: SanityClient,
  baseLanguage?: string,
  mergeWithTargetLocale?: boolean,
) => Promise<void>

export declare const findLatestDraft: (
  documentId: string,
  client: SanityClient,
) => Promise<SanityDocument>

export declare type ImportTranslation = (
  id: string,
  localeId: string,
  document: string,
  context: TranslationFunctionContext,
  baseLanguage?: string,
  serializationOptions?: {
    additionalDeserializers?: Record<string, (value: HTMLElement) => TypedObject>
    additionalBlockDeserializers?: DeserializerRule[]
  },
  languageField?: string,
  mergeWithTargetLocale?: boolean,
) => Promise<void>

export declare const legacyDocumentLevelConfig: {
  importTranslation: (
    id: string,
    localeId: string,
    document: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalDeserializers?: Record<string, (value: HTMLElement) => TypedObject> | undefined
          additionalBlockDeserializers?: DeserializerRule[] | undefined
        }
      | undefined,
    languageField?: string | undefined,
    mergeWithTargetLocale?: boolean | undefined,
  ) => Promise<void>
  exportForTranslation: (
    id: string,
    context: TranslationFunctionContext,
    baseLanguage?: string | undefined,
    serializationOptions?:
      | {
          additionalStopTypes?: string[] | undefined
          additionalSerializers?: Record<string, PortableTextTypeComponent | undefined> | undefined
        }
      | undefined,
    languageField?: string | undefined,
  ) => Promise<SerializedDocument>
  adapter: Adapter
  secretsNamespace: string
  baseLanguage: string
}

export declare const legacyDocumentLevelPatch: (
  documentId: string,
  translatedFields: SanityDocument,
  localeId: string,
  client: SanityClient,
) => Promise<void>

export declare type Secrets = {
  organization: string
  project: string
  token?: string
  secret?: string
  username?: string
  password?: string
  proxy?: string
}

export {SerializedDocument}

export declare interface TranslationFunctionContext {
  client: SanityClient
  schema: Schema
}

declare type TranslationLocale = {
  localeId: string
  description: string
  enabled?: boolean
}

export declare const TranslationsTab: (props: TranslationTabProps) => JSX_2.Element

export declare type TranslationsTabConfigOptions = {
  adapter: Adapter
  baseLanguage: string
  secretsNamespace: string | null
  exportForTranslation: ExportForTranslation
  importTranslation: ImportTranslation
  serializationOptions?: {
    additionalStopTypes?: string[]
    additionalSerializers?: Record<string, PortableTextTypeComponent | undefined>
    additionalDeserializers?: Record<string, (value: HTMLElement) => TypedObject>
    additionalBlockDeserializers?: DeserializerRule[]
  }
  workflowOptions?: WorkflowIdentifiers[]
  localeIdAdapter?: (id: string) => string
  languageField?: string
  callbackUrl?: string
  mergeWithTargetLocale?: boolean
}

declare type TranslationTabProps = {
  document: {
    displayed: SanityDocument
  }
  options: TranslationsTabConfigOptions
}

declare type TranslationTask = {
  taskId: string
  documentId: string
  locales: TranslationTaskLocaleStatus[]
  linkToVendorTask?: string
}

declare type TranslationTaskLocaleStatus = {
  localeId: string
  progress: number
}

declare type WorkflowIdentifiers = {
  workflowUid: string
  workflowName: string
}

export {}
