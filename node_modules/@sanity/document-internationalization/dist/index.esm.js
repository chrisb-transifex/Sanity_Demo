import { jsx, jsxs, Fragment } from "react/jsx-runtime";
import { TrashIcon, CogIcon, SplitVerticalIcon, CheckmarkIcon, AddIcon, EditIcon, TranslateIcon, InfoOutlineIcon } from "@sanity/icons";
import { Flex, Spinner, Stack, Text, Card, Grid, Button, useToast, Tooltip, Box, Badge, useClickOutside, TextInput, Popover, Inline, Dialog } from "@sanity/ui";
import { useMemo, useEffect, createContext, useContext, useState, useCallback } from "react";
import { useSchema, Preview, useClient, useWorkspace, isDocumentSchemaType, pathToString, useEditState, useValidationStatus, TextWithTone, PatchEvent, unset, defineType, defineField, definePlugin, isSanityDocument } from "sanity";
import { Feedback, useListeningQuery } from "sanity-plugin-utils";
import { uuid } from "@sanity/uuid";
import { RouterContext } from "sanity/router";
import { usePaneRouter, useDocumentPane } from "sanity/structure";
import { Mutation, extractWithPath } from "@sanity/mutator";
import { styled } from "styled-components";
import { internationalizedArray } from "sanity-plugin-internationalized-array";
function DocumentPreview(props) {
  const schemaType = useSchema().get(props.type);
  return schemaType ? /* @__PURE__ */ jsx(Preview, { value: props.value, schemaType }) : /* @__PURE__ */ jsx(Feedback, { tone: "critical", title: "Schema type not found" });
}
const METADATA_SCHEMA_NAME = "translation.metadata", TRANSLATIONS_ARRAY_NAME = "translations", API_VERSION = "2023-05-22", DEFAULT_CONFIG = {
  supportedLanguages: [],
  schemaTypes: [],
  languageField: "language",
  weakReferences: !1,
  bulkPublish: !1,
  metadataFields: [],
  apiVersion: API_VERSION
};
function separateReferences(data = []) {
  const translations = [], otherReferences = [];
  return data && data.length > 0 && data.forEach((doc) => {
    doc._type === METADATA_SCHEMA_NAME ? translations.push(doc) : otherReferences.push(doc);
  }), { translations, otherReferences };
}
function DeleteTranslationDialog(props) {
  const { doc, documentId, setTranslations } = props, { data, loading } = useListeningQuery(
    "*[references($id)]{_id, _type}",
    { params: { id: documentId }, initialValue: [] }
  ), { translations, otherReferences } = useMemo(
    () => separateReferences(data),
    [data]
  );
  return useEffect(() => {
    setTranslations(translations);
  }, [setTranslations, translations]), loading ? /* @__PURE__ */ jsx(Flex, { padding: 4, align: "center", justify: "center", children: /* @__PURE__ */ jsx(Spinner, {}) }) : /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
    translations && translations.length > 0 ? /* @__PURE__ */ jsx(Text, { children: "This document is a language-specific version which other translations depend on." }) : /* @__PURE__ */ jsx(Text, { children: "This document does not have connected translations." }),
    /* @__PURE__ */ jsx(Card, { border: !0, padding: 3, children: /* @__PURE__ */ jsxs(Stack, { space: 4, children: [
      /* @__PURE__ */ jsx(Text, { size: 1, weight: "semibold", children: translations && translations.length > 0 ? /* @__PURE__ */ jsx(Fragment, { children: "Before this document can be deleted" }) : /* @__PURE__ */ jsx(Fragment, { children: "This document can now be deleted" }) }),
      /* @__PURE__ */ jsx(DocumentPreview, { value: doc, type: doc._type }),
      translations && translations.length > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Card, { borderTop: !0 }),
        /* @__PURE__ */ jsxs(Text, { size: 1, weight: "semibold", children: [
          "The reference in",
          " ",
          translations.length === 1 ? "this translations document" : "these translations documents",
          " ",
          "must be removed"
        ] }),
        translations.map((translation) => /* @__PURE__ */ jsx(
          DocumentPreview,
          {
            value: translation,
            type: translation._type
          },
          translation._id
        ))
      ] }) : null,
      otherReferences && otherReferences.length > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
        /* @__PURE__ */ jsx(Card, { borderTop: !0 }),
        /* @__PURE__ */ jsxs(Text, { size: 1, weight: "semibold", children: [
          otherReferences.length === 1 ? "There is an additional reference" : "There are additional references",
          " ",
          "to this document"
        ] }),
        otherReferences.map((reference) => /* @__PURE__ */ jsx(
          DocumentPreview,
          {
            value: reference,
            type: reference._type
          },
          reference._id
        ))
      ] }) : null
    ] }) }),
    otherReferences.length === 0 ? /* @__PURE__ */ jsx(Text, { children: "This document has no other references." }) : /* @__PURE__ */ jsx(Text, { children: "You may not be able to delete this document because other documents refer to it." })
  ] });
}
function DeleteTranslationFooter(props) {
  const { translations, onClose, onProceed } = props;
  return /* @__PURE__ */ jsxs(Grid, { columns: 2, gap: 2, children: [
    /* @__PURE__ */ jsx(Button, { text: "Cancel", onClick: onClose, mode: "ghost" }),
    /* @__PURE__ */ jsx(
      Button,
      {
        text: translations && translations.length > 0 ? "Unset translation reference" : "Delete document",
        onClick: onProceed,
        tone: "critical"
      }
    )
  ] });
}
const isPromise = (promise) => typeof promise == "object" && typeof promise.then == "function", globalCache = [];
function shallowEqualArrays(arrA, arrB, equal = (a, b) => a === b) {
  if (arrA === arrB)
    return !0;
  if (!arrA || !arrB)
    return !1;
  const len = arrA.length;
  if (arrB.length !== len)
    return !1;
  for (let i = 0; i < len; i++)
    if (!equal(arrA[i], arrB[i]))
      return !1;
  return !0;
}
function query$1(fn, keys = null, preload = !1, config = {}) {
  keys === null && (keys = [fn]);
  for (const entry2 of globalCache)
    if (shallowEqualArrays(keys, entry2.keys, entry2.equal)) {
      if (preload)
        return;
      if (Object.prototype.hasOwnProperty.call(entry2, "error"))
        throw entry2.error;
      if (Object.prototype.hasOwnProperty.call(entry2, "response"))
        return config.lifespan && config.lifespan > 0 && (entry2.timeout && clearTimeout(entry2.timeout), entry2.timeout = setTimeout(entry2.remove, config.lifespan)), entry2.response;
      if (!preload)
        throw entry2.promise;
    }
  const entry = {
    keys,
    equal: config.equal,
    remove: () => {
      const index = globalCache.indexOf(entry);
      index !== -1 && globalCache.splice(index, 1);
    },
    promise: (
      // Execute the promise
      (isPromise(fn) ? fn : fn(...keys)).then((response) => {
        entry.response = response, config.lifespan && config.lifespan > 0 && (entry.timeout = setTimeout(entry.remove, config.lifespan));
      }).catch((error) => entry.error = error)
    )
  };
  if (globalCache.push(entry), !preload)
    throw entry.promise;
}
const suspend = (fn, keys, config) => query$1(fn, keys, !1, config), DocumentInternationalizationContext = createContext(DEFAULT_CONFIG);
function useDocumentInternationalizationContext() {
  return useContext(DocumentInternationalizationContext);
}
function DocumentInternationalizationProvider(props) {
  const { pluginConfig } = props, client = useClient({ apiVersion: pluginConfig.apiVersion }), workspace = useWorkspace(), supportedLanguages = Array.isArray(pluginConfig.supportedLanguages) ? pluginConfig.supportedLanguages : (
    // eslint-disable-next-line require-await
    suspend(async () => typeof pluginConfig.supportedLanguages == "function" ? pluginConfig.supportedLanguages(client) : pluginConfig.supportedLanguages, [workspace])
  );
  return /* @__PURE__ */ jsx(
    DocumentInternationalizationContext.Provider,
    {
      value: { ...pluginConfig, supportedLanguages },
      children: props.renderDefault(props)
    }
  );
}
const DeleteTranslationAction = (props) => {
  const { id: documentId, published, draft } = props, doc = draft || published, { languageField } = useDocumentInternationalizationContext(), [isDialogOpen, setDialogOpen] = useState(!1), [translations, setTranslations] = useState([]), onClose = useCallback(() => setDialogOpen(!1), []), documentLanguage = doc ? doc[languageField] : null, toast = useToast(), client = useClient({ apiVersion: API_VERSION }), onProceed = useCallback(() => {
    const tx = client.transaction();
    let operation = "DELETE";
    documentLanguage && translations.length > 0 ? (operation = "UNSET", translations.forEach((translation) => {
      tx.patch(
        translation._id,
        (patch) => patch.unset([
          `${TRANSLATIONS_ARRAY_NAME}[_key == "${documentLanguage}"]`
        ])
      );
    })) : (tx.delete(documentId), tx.delete(`drafts.${documentId}`)), tx.commit().then(() => {
      operation === "DELETE" && onClose(), toast.push({
        status: "success",
        title: operation === "UNSET" ? "Translation reference unset" : "Document deleted",
        description: operation === "UNSET" ? "The document can now be deleted" : null
      });
    }).catch((err) => {
      toast.push({
        status: "error",
        title: operation === "unset" ? "Failed to unset translation reference" : "Failed to delete document",
        description: err.message
      });
    });
  }, [client, documentLanguage, translations, documentId, onClose, toast]);
  return {
    label: "Delete translation...",
    disabled: !doc || !documentLanguage,
    icon: TrashIcon,
    tone: "critical",
    onHandle: () => {
      setDialogOpen(!0);
    },
    dialog: isDialogOpen && {
      type: "dialog",
      onClose,
      header: "Delete translation",
      content: doc ? /* @__PURE__ */ jsx(
        DeleteTranslationDialog,
        {
          doc,
          documentId,
          setTranslations
        }
      ) : null,
      footer: /* @__PURE__ */ jsx(
        DeleteTranslationFooter,
        {
          onClose,
          onProceed,
          translations
        }
      )
    }
  };
}, query = `*[_type == $translationSchema && $id in translations[].value._ref]{
  _id,
  _createdAt,
  translations
}`;
function useTranslationMetadata(id) {
  const { data, loading, error } = useListeningQuery(query, {
    params: { id, translationSchema: METADATA_SCHEMA_NAME }
  });
  return { data, loading, error };
}
function useOpenInNewPane(id, type) {
  const routerContext = useContext(RouterContext), { routerPanesState, groupIndex } = usePaneRouter();
  return useCallback(() => {
    if (!routerContext || !id || !type)
      return;
    if (!routerPanesState.length) {
      routerContext.navigateIntent("edit", { id, type });
      return;
    }
    const panes = [...routerPanesState];
    panes.splice(groupIndex + 1, 0, [
      {
        id,
        params: { type }
      }
    ]);
    const href = routerContext.resolvePathFromState({ panes });
    routerContext.navigateUrl({ path: href });
  }, [id, type, routerContext, routerPanesState, groupIndex]);
}
function LanguageManage(props) {
  const { id } = props, open = useOpenInNewPane(id, METADATA_SCHEMA_NAME);
  return /* @__PURE__ */ jsx(
    Tooltip,
    {
      animate: !0,
      content: id ? null : /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: "Document has no other translations" }) }),
      fallbackPlacements: ["right", "left"],
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsx(Stack, { children: /* @__PURE__ */ jsx(
        Button,
        {
          disabled: !id,
          mode: "ghost",
          text: "Manage Translations",
          icon: CogIcon,
          onClick: () => open()
        }
      ) })
    }
  );
}
function createReference(key, ref, type, strengthenOnPublish = !0) {
  return {
    _key: key,
    _type: "internationalizedArrayReferenceValue",
    value: {
      _type: "reference",
      _ref: ref,
      _weak: !0,
      // If the user has configured weakReferences, we won't want to strengthen them
      ...strengthenOnPublish ? { _strengthenOnPublish: { type } } : {}
    }
  };
}
function removeExcludedPaths(doc, schemaType) {
  if (!isDocumentSchemaType(schemaType) || !doc)
    return doc;
  const pathsToExclude = extractPaths(doc, schemaType, []).filter(
    (field) => {
      var _a, _b, _c;
      return ((_c = (_b = (_a = field.schemaType) == null ? void 0 : _a.options) == null ? void 0 : _b.documentInternationalization) == null ? void 0 : _c.exclude) === !0;
    }
  ).map((field) => pathToString(field.path));
  return new Mutation({
    mutations: [
      {
        patch: {
          id: doc._id,
          unset: pathsToExclude
        }
      }
    ]
  }).apply(doc);
}
function extractPaths(doc, schemaType, path) {
  return schemaType.fields.reduce((acc, field) => {
    var _a, _b;
    const fieldPath = [...path, field.name], fieldSchema = field.type, { value } = (_a = extractWithPath(pathToString(fieldPath), doc)[0]) != null ? _a : {};
    if (!value)
      return acc;
    const thisFieldWithPath = {
      path: fieldPath,
      name: field.name,
      schemaType: fieldSchema,
      value
    };
    if (fieldSchema.jsonType === "object") {
      const innerFields = extractPaths(doc, fieldSchema, fieldPath);
      return [...acc, thisFieldWithPath, ...innerFields];
    } else if (fieldSchema.jsonType === "array" && fieldSchema.of.length && fieldSchema.of.some((item) => "fields" in item)) {
      const { value: arrayValue } = (_b = extractWithPath(pathToString(fieldPath), doc)[0]) != null ? _b : {};
      let arrayPaths = [];
      if (arrayValue != null && arrayValue.length)
        for (const item of arrayValue) {
          const itemPath = [...fieldPath, { _key: item._key }];
          let itemSchema = fieldSchema.of.find((t) => t.name === item._type);
          if (item._type || (itemSchema = fieldSchema.of[0]), item._key && itemSchema) {
            const innerFields = extractPaths(
              doc,
              itemSchema,
              itemPath
            ), arrayMember = {
              path: itemPath,
              name: item._key,
              schemaType: itemSchema,
              value: item
            };
            arrayPaths = [...arrayPaths, arrayMember, ...innerFields];
          }
        }
      return [...acc, thisFieldWithPath, ...arrayPaths];
    }
    return [...acc, thisFieldWithPath];
  }, []);
}
function LanguageOption(props) {
  var _a;
  const {
    language,
    schemaType,
    documentId,
    current,
    source,
    sourceLanguageId,
    metadata: metadata2,
    metadataId
  } = props, disabled = props.disabled || current || !source || !sourceLanguageId || !metadataId, translation = metadata2 != null && metadata2.translations.length ? metadata2.translations.find((t) => t._key === language.id) : void 0, { apiVersion, languageField, weakReferences } = useDocumentInternationalizationContext(), client = useClient({ apiVersion }), toast = useToast(), open = useOpenInNewPane((_a = translation == null ? void 0 : translation.value) == null ? void 0 : _a._ref, schemaType.name), handleOpen = useCallback(() => open(), [open]), handleCreate = useCallback(async () => {
    if (!source)
      throw new Error("Cannot create translation without source document");
    if (!sourceLanguageId)
      throw new Error("Cannot create translation without source language ID");
    if (!metadataId)
      throw new Error("Cannot create translation without a metadata ID");
    const transaction = client.transaction(), newTranslationDocumentId = uuid();
    let newTranslationDocument = {
      ...source,
      _id: `drafts.${newTranslationDocumentId}`,
      // 2. Update language of the translation
      [languageField]: language.id
    };
    newTranslationDocument = removeExcludedPaths(
      newTranslationDocument,
      schemaType
    ), transaction.create(newTranslationDocument);
    const sourceReference = createReference(
      sourceLanguageId,
      documentId,
      schemaType.name,
      !weakReferences
    ), newTranslationReference = createReference(
      language.id,
      newTranslationDocumentId,
      schemaType.name,
      !weakReferences
    ), newMetadataDocument = {
      _id: metadataId,
      _type: METADATA_SCHEMA_NAME,
      schemaTypes: [schemaType.name],
      translations: [sourceReference]
    };
    transaction.createIfNotExists(newMetadataDocument);
    const metadataPatch = client.patch(metadataId).setIfMissing({ translations: [sourceReference] }).insert("after", "translations[-1]", [newTranslationReference]);
    transaction.patch(metadataPatch), transaction.commit().then(() => {
      const metadataExisted = !!(metadata2 != null && metadata2._createdAt);
      return toast.push({
        status: "success",
        title: `Created "${language.title}" translation`,
        description: metadataExisted ? "Updated Translations Metadata" : "Created Translations Metadata"
      });
    }).catch((err) => (console.error(err), toast.push({
      status: "error",
      title: "Error creating translation",
      description: err.message
    })));
  }, [
    client,
    documentId,
    language.id,
    language.title,
    languageField,
    metadata2 == null ? void 0 : metadata2._createdAt,
    metadataId,
    schemaType,
    source,
    sourceLanguageId,
    toast,
    weakReferences
  ]);
  let message;
  return current ? message = "Current document" : translation ? message = `Open ${language.title} translation` : translation || (message = `Create new ${language.title} translation`), /* @__PURE__ */ jsx(
    Tooltip,
    {
      animate: !0,
      content: /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: message }) }),
      fallbackPlacements: ["right", "left"],
      placement: "top",
      portal: !0,
      children: /* @__PURE__ */ jsx(
        Button,
        {
          onClick: translation ? handleOpen : handleCreate,
          mode: current && disabled ? "default" : "bleed",
          disabled,
          children: /* @__PURE__ */ jsxs(Flex, { gap: 3, align: "center", children: [
            disabled && !current ? /* @__PURE__ */ jsx(Spinner, {}) : /* @__PURE__ */ jsx(Text, { size: 2, children: translation ? /* @__PURE__ */ jsx(SplitVerticalIcon, {}) : current ? /* @__PURE__ */ jsx(CheckmarkIcon, {}) : /* @__PURE__ */ jsx(AddIcon, {}) }),
            /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { children: language.title }) }),
            /* @__PURE__ */ jsx(Badge, { tone: disabled || current ? "default" : "primary", children: language.id })
          ] })
        }
      )
    }
  );
}
function LanguagePatch(props) {
  const { language, source } = props, { apiVersion, languageField } = useDocumentInternationalizationContext(), disabled = props.disabled || !source, client = useClient({ apiVersion }), toast = useToast(), handleClick = useCallback(() => {
    if (!source)
      throw new Error("Cannot patch missing document");
    const currentId = source._id;
    client.patch(currentId).set({ [languageField]: language.id }).commit().then(() => {
      toast.push({
        title: `Set document language to ${language.title}`,
        status: "success"
      });
    }).catch((err) => (console.error(err), toast.push({
      title: `Failed to set document language to ${language.title}`,
      status: "error"
    })));
  }, [source, client, languageField, language, toast]);
  return /* @__PURE__ */ jsx(
    Button,
    {
      mode: "bleed",
      onClick: handleClick,
      disabled,
      justify: "flex-start",
      children: /* @__PURE__ */ jsxs(Flex, { gap: 3, align: "center", children: [
        /* @__PURE__ */ jsx(Text, { size: 2, children: /* @__PURE__ */ jsx(EditIcon, {}) }),
        /* @__PURE__ */ jsx(Box, { flex: 1, children: /* @__PURE__ */ jsx(Text, { children: language.title }) }),
        /* @__PURE__ */ jsx(Badge, { children: language.id })
      ] })
    }
  );
}
var ConstrainedBox = styled(Box)`
  max-width: 280px;
`;
function Warning({ children }) {
  return /* @__PURE__ */ jsx(Card, { tone: "caution", padding: 3, children: /* @__PURE__ */ jsx(Flex, { justify: "center", children: /* @__PURE__ */ jsx(ConstrainedBox, { children: /* @__PURE__ */ jsx(Text, { size: 1, align: "center", children }) }) }) });
}
function DocumentInternationalizationMenu(props) {
  const { documentId } = props, schemaType = props.schemaType, { languageField, supportedLanguages } = useDocumentInternationalizationContext(), [query2, setQuery] = useState(""), handleQuery = useCallback((event) => {
    event.currentTarget.value ? setQuery(event.currentTarget.value) : setQuery("");
  }, []), [open, setOpen] = useState(!1), handleClick = useCallback(() => setOpen((o) => !o), []), [button, setButton] = useState(null), [popover, setPopover] = useState(null), handleClickOutside = useCallback(() => setOpen(!1), []);
  useClickOutside(handleClickOutside, [button, popover]);
  const { data, loading, error } = useTranslationMetadata(documentId), metadata2 = Array.isArray(data) && data.length ? data[0] : null, metadataId = useMemo(() => {
    var _a;
    return loading ? null : (_a = metadata2 == null ? void 0 : metadata2._id) != null ? _a : uuid();
  }, [loading, metadata2 == null ? void 0 : metadata2._id]), { draft, published } = useEditState(documentId, schemaType.name), source = draft || published, documentIsInOneMetadataDocument = useMemo(() => Array.isArray(data) && data.length <= 1, [data]), sourceLanguageId = source == null ? void 0 : source[languageField], sourceLanguageIsValid = supportedLanguages.some(
    (l) => l.id === sourceLanguageId
  ), allLanguagesAreValid = useMemo(() => {
    const valid = supportedLanguages.every((l) => l.id && l.title);
    return valid || console.warn(
      'Not all languages are valid. It should be an array of objects with an "id" and "title" property. Or a function that returns an array of objects with an "id" and "title" property.',
      supportedLanguages
    ), valid;
  }, [supportedLanguages]), content = /* @__PURE__ */ jsx(Box, { padding: 1, children: error ? /* @__PURE__ */ jsx(Card, { tone: "critical", padding: 1, children: /* @__PURE__ */ jsx(Text, { children: "There was an error returning translations metadata" }) }) : /* @__PURE__ */ jsxs(Stack, { space: 1, children: [
    /* @__PURE__ */ jsx(LanguageManage, { id: metadata2 == null ? void 0 : metadata2._id }),
    supportedLanguages.length > 4 ? /* @__PURE__ */ jsx(
      TextInput,
      {
        onChange: handleQuery,
        value: query2,
        placeholder: "Filter languages"
      }
    ) : null,
    supportedLanguages.length > 0 ? /* @__PURE__ */ jsxs(Fragment, { children: [
      loading ? null : /* @__PURE__ */ jsxs(Fragment, { children: [
        data && documentIsInOneMetadataDocument ? null : /* @__PURE__ */ jsx(Warning, { children: "This document has been found in more than one Translations Metadata documents" }),
        allLanguagesAreValid ? null : /* @__PURE__ */ jsx(Warning, { children: "Not all language objects are valid. See the console." }),
        sourceLanguageId ? null : /* @__PURE__ */ jsxs(Warning, { children: [
          "Choose a language to apply to",
          " ",
          /* @__PURE__ */ jsx("strong", { children: "this Document" })
        ] }),
        sourceLanguageId && !sourceLanguageIsValid ? /* @__PURE__ */ jsxs(Warning, { children: [
          "Select a supported language. Current language value:",
          " ",
          /* @__PURE__ */ jsx("code", { children: sourceLanguageId })
        ] }) : null
      ] }),
      supportedLanguages.filter((language) => query2 ? language.title.toLowerCase().includes(query2.toLowerCase()) : !0).map(
        (language) => {
          var _a;
          return !loading && sourceLanguageId && sourceLanguageIsValid ? (
            // Button to duplicate this document to a new translation
            // And either create or update the metadata document
            /* @__PURE__ */ jsx(
              LanguageOption,
              {
                language,
                schemaType,
                documentId,
                disabled: loading || !allLanguagesAreValid,
                current: language.id === sourceLanguageId,
                metadata: metadata2,
                metadataId,
                source,
                sourceLanguageId
              },
              language.id
            )
          ) : (
            // Button to set a language field on *this* document
            /* @__PURE__ */ jsx(
              LanguagePatch,
              {
                source,
                language,
                disabled: (_a = loading || !allLanguagesAreValid || (metadata2 == null ? void 0 : metadata2.translations.filter((t) => {
                  var _a2;
                  return ((_a2 = t == null ? void 0 : t.value) == null ? void 0 : _a2._ref) !== documentId;
                }).some((t) => t._key === language.id))) != null ? _a : !1
              },
              language.id
            )
          );
        }
      )
    ] }) : null
  ] }) }), issueWithTranslations = !loading && sourceLanguageId && !sourceLanguageIsValid;
  return !documentId || !schemaType || !schemaType.name ? null : /* @__PURE__ */ jsx(
    Popover,
    {
      animate: !0,
      constrainSize: !0,
      content,
      open,
      portal: !0,
      ref: setPopover,
      overflow: "auto",
      tone: "default",
      children: /* @__PURE__ */ jsx(
        Button,
        {
          text: "Translations",
          mode: "bleed",
          disabled: !source,
          tone: !source || loading || !issueWithTranslations ? void 0 : "caution",
          icon: TranslateIcon,
          onClick: handleClick,
          ref: setButton,
          selected: open
        }
      )
    }
  );
}
const DeleteMetadataAction = (props) => {
  const { id: documentId, published, draft, onComplete } = props, doc = draft || published, [isDialogOpen, setDialogOpen] = useState(!1), onClose = useCallback(() => setDialogOpen(!1), []), translations = useMemo(
    () => doc && Array.isArray(doc[TRANSLATIONS_ARRAY_NAME]) ? doc[TRANSLATIONS_ARRAY_NAME] : [],
    [doc]
  ), toast = useToast(), client = useClient({ apiVersion: API_VERSION }), onProceed = useCallback(() => {
    const tx = client.transaction();
    tx.patch(documentId, (patch) => patch.unset([TRANSLATIONS_ARRAY_NAME])), translations.length > 0 && translations.forEach((translation) => {
      tx.delete(translation.value._ref), tx.delete(`drafts.${translation.value._ref}`);
    }), tx.delete(documentId), tx.delete(`drafts.${documentId}`), tx.commit().then(() => {
      onClose(), toast.push({
        status: "success",
        title: "Deleted document and translations"
      });
    }).catch((err) => {
      toast.push({
        status: "error",
        title: "Failed to delete document and translations",
        description: err.message
      });
    });
  }, [client, translations, documentId, onClose, toast]);
  return {
    label: "Delete all translations",
    disabled: !doc || !translations.length,
    icon: TrashIcon,
    tone: "critical",
    onHandle: () => {
      setDialogOpen(!0);
    },
    dialog: isDialogOpen && {
      type: "confirm",
      onCancel: onComplete,
      onConfirm: () => {
        onProceed(), onComplete();
      },
      tone: "critical",
      message: translations.length === 1 ? "Delete 1 translation and this document" : `Delete all ${translations.length} translations and this document`
    }
  };
};
function LanguageBadge(props) {
  var _a, _b;
  const source = (props == null ? void 0 : props.draft) || (props == null ? void 0 : props.published), { languageField, supportedLanguages } = useDocumentInternationalizationContext(), languageId = source == null ? void 0 : source[languageField];
  if (!languageId)
    return null;
  const language = Array.isArray(supportedLanguages) ? supportedLanguages.find((l) => l.id === languageId) : null;
  return {
    label: (_a = language == null ? void 0 : language.id) != null ? _a : String(languageId),
    title: (_b = language == null ? void 0 : language.title) != null ? _b : void 0,
    color: "primary"
  };
}
function DocumentCheck(props) {
  const {
    id,
    onCheckComplete,
    addInvalidId,
    removeInvalidId,
    addDraftId,
    removeDraftId
  } = props, editState = useEditState(id, ""), { isValidating, validation } = useValidationStatus(id, ""), schema = useSchema(), validationHasErrors = useMemo(() => !isValidating && validation.length > 0 && validation.some((item) => item.level === "error"), [isValidating, validation]);
  if (useEffect(() => {
    validationHasErrors ? addInvalidId(id) : removeInvalidId(id), editState.draft ? addDraftId(id) : removeDraftId(id), isValidating || onCheckComplete(id);
  }, [
    addDraftId,
    addInvalidId,
    editState.draft,
    id,
    isValidating,
    onCheckComplete,
    removeDraftId,
    removeInvalidId,
    validationHasErrors
  ]), !editState.draft)
    return null;
  const schemaType = schema.get(editState.draft._type);
  return /* @__PURE__ */ jsx(
    Card,
    {
      border: !0,
      padding: 2,
      tone: validationHasErrors ? "critical" : "positive",
      children: editState.draft && schemaType ? /* @__PURE__ */ jsx(
        Preview,
        {
          layout: "default",
          value: editState.draft,
          schemaType
        }
      ) : /* @__PURE__ */ jsx(Spinner, {})
    }
  );
}
function InfoIcon(props) {
  const { text, icon, tone, children } = props;
  return /* @__PURE__ */ jsx(
    Tooltip,
    {
      animate: !0,
      portal: !0,
      content: children ? /* @__PURE__ */ jsx(Fragment, { children }) : /* @__PURE__ */ jsx(Box, { padding: 2, children: /* @__PURE__ */ jsx(Text, { size: 1, children: text }) }),
      children: /* @__PURE__ */ jsx(TextWithTone, { tone, size: 1, children: /* @__PURE__ */ jsx(icon, {}) })
    }
  );
}
function Info() {
  return /* @__PURE__ */ jsx(InfoIcon, { icon: InfoOutlineIcon, tone: "primary", children: /* @__PURE__ */ jsxs(Stack, { padding: 3, space: 4, style: { maxWidth: 250 }, children: [
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, children: "Bulk publishing uses the Scheduling API." }) }),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, children: "Customized Document Actions in the Studio will not execute. Webhooks will execute." }) }),
    /* @__PURE__ */ jsx(Box, { children: /* @__PURE__ */ jsx(Text, { size: 1, children: "Validation is checked before rendering the button below, but the Scheduling API will not check for \u2013 or enforce \u2013 validation." }) })
  ] }) });
}
function BulkPublish(props) {
  const { translations } = props, client = useClient({ apiVersion: API_VERSION }), { projectId, dataset } = useWorkspace(), toast = useToast(), [invalidIds, setInvalidIds] = useState(null), [checkedIds, setCheckedIds] = useState([]), onCheckComplete = useCallback((id) => {
    setCheckedIds((ids) => Array.from(/* @__PURE__ */ new Set([...ids, id])));
  }, []), [open, setOpen] = useState(!1), onOpen = useCallback(() => setOpen(!0), []), onClose = useCallback(() => setOpen(!1), []), addInvalidId = useCallback((id) => {
    setInvalidIds((ids) => ids ? Array.from(/* @__PURE__ */ new Set([...ids, id])) : [id]);
  }, []), removeInvalidId = useCallback((id) => {
    setInvalidIds((ids) => ids ? ids.filter((i) => i !== id) : []);
  }, []), [draftIds, setDraftIds] = useState([]), addDraftId = useCallback((id) => {
    setDraftIds((ids) => Array.from(/* @__PURE__ */ new Set([...ids, id])));
  }, []), removeDraftId = useCallback((id) => {
    setDraftIds((ids) => ids.filter((i) => i !== id));
  }, []), handleBulkPublish = useCallback(() => {
    const body = translations.map((translation) => ({
      documentId: translation.value._ref
    }));
    client.request({
      uri: `/publish/${projectId}/${dataset}`,
      method: "POST",
      body
    }).then(() => {
      toast.push({
        status: "success",
        title: "Success",
        description: "Bulk publish complete"
      });
    }).catch((err) => {
      console.error(err), toast.push({
        status: "error",
        title: "Error",
        description: "Bulk publish failed"
      });
    });
  }, [translations, client, projectId, dataset, toast]), disabled = (
    // Not all documents have been checked
    checkedIds.length !== translations.length || // Some document(s) are invalid
    !!(invalidIds && (invalidIds == null ? void 0 : invalidIds.length) > 0) || // No documents are drafts
    !draftIds.length
  );
  return (translations == null ? void 0 : translations.length) > 0 ? /* @__PURE__ */ jsx(Card, { padding: 4, border: !0, radius: 2, children: /* @__PURE__ */ jsxs(Stack, { space: 3, children: [
    /* @__PURE__ */ jsxs(Inline, { space: 3, children: [
      /* @__PURE__ */ jsx(Text, { weight: "bold", size: 1, children: "Bulk publishing" }),
      /* @__PURE__ */ jsx(Info, {})
    ] }),
    /* @__PURE__ */ jsx(Stack, { children: /* @__PURE__ */ jsx(
      Button,
      {
        onClick: onOpen,
        text: "Prepare bulk publishing",
        mode: "ghost"
      }
    ) }),
    open && /* @__PURE__ */ jsx(
      Dialog,
      {
        animate: !0,
        header: "Bulk publishing",
        id: "bulk-publish-dialog",
        onClose,
        zOffset: 1e3,
        width: 3,
        children: /* @__PURE__ */ jsxs(Stack, { space: 4, padding: 4, children: [
          draftIds.length > 0 ? /* @__PURE__ */ jsxs(Stack, { space: 2, children: [
            /* @__PURE__ */ jsxs(Text, { size: 1, children: [
              "There",
              " ",
              draftIds.length === 1 ? "is 1 draft document" : `are ${draftIds.length} draft documents`,
              "."
            ] }),
            invalidIds && invalidIds.length > 0 ? /* @__PURE__ */ jsxs(TextWithTone, { tone: "critical", size: 1, children: [
              invalidIds && invalidIds.length === 1 ? "1 draft document has" : `${invalidIds && invalidIds.length} draft documents have`,
              " ",
              "validation issues that must addressed first"
            ] }) : /* @__PURE__ */ jsx(TextWithTone, { tone: "positive", size: 1, children: "All drafts are valid and can be bulk published" })
          ] }) : null,
          /* @__PURE__ */ jsx(Stack, { space: 1, children: translations.filter((translation) => {
            var _a;
            return (_a = translation == null ? void 0 : translation.value) == null ? void 0 : _a._ref;
          }).map((translation) => /* @__PURE__ */ jsx(
            DocumentCheck,
            {
              id: translation.value._ref,
              onCheckComplete,
              addInvalidId,
              removeInvalidId,
              addDraftId,
              removeDraftId
            },
            translation._key
          )) }),
          draftIds.length > 0 ? /* @__PURE__ */ jsx(
            Button,
            {
              mode: "ghost",
              tone: invalidIds && (invalidIds == null ? void 0 : invalidIds.length) > 0 ? "caution" : "positive",
              text: draftIds.length === 1 ? "Publish draft document" : `Bulk publish ${draftIds.length} draft documents`,
              onClick: handleBulkPublish,
              disabled
            }
          ) : /* @__PURE__ */ jsx(Text, { muted: !0, size: 1, children: "No draft documents to publish" })
        ] })
      }
    )
  ] }) }) : null;
}
function ReferencePatcher(props) {
  const { translation, documentType, metadataId } = props, editState = useEditState(translation.value._ref, documentType), client = useClient({ apiVersion: API_VERSION }), { onChange } = useDocumentPane();
  return useEffect(() => {
    if (
      // We have a reference
      translation.value._ref && // It's still weak and not-yet-strengthened
      translation.value._weak && // We also want to keep this check because maybe the user *configured* weak refs
      translation.value._strengthenOnPublish && // The referenced document has just been published
      !editState.draft && editState.published && editState.ready
    ) {
      const referencePathBase = [
        "translations",
        { _key: translation._key },
        "value"
      ];
      onChange(
        new PatchEvent([
          unset([...referencePathBase, "_weak"]),
          unset([...referencePathBase, "_strengthenOnPublish"])
        ])
      );
    }
  }, [translation, editState, metadataId, client, onChange]), null;
}
function OptimisticallyStrengthen(props) {
  const { translations = [], metadataId } = props;
  return translations.length ? /* @__PURE__ */ jsx(Fragment, { children: translations.map(
    (translation) => {
      var _a;
      return (_a = translation.value._strengthenOnPublish) != null && _a.type ? /* @__PURE__ */ jsx(
        ReferencePatcher,
        {
          translation,
          documentType: translation.value._strengthenOnPublish.type,
          metadataId
        },
        translation._key
      ) : null;
    }
  ) }) : null;
}
var metadata = (schemaTypes, metadataFields) => defineType({
  type: "document",
  name: METADATA_SCHEMA_NAME,
  title: "Translation metadata",
  icon: TranslateIcon,
  liveEdit: !0,
  fields: [
    defineField({
      name: TRANSLATIONS_ARRAY_NAME,
      type: "internationalizedArrayReference"
    }),
    defineField({
      name: "schemaTypes",
      description: "Optional: Used to filter the reference fields above so all translations share the same types.",
      type: "array",
      of: [{ type: "string" }],
      options: { list: schemaTypes },
      readOnly: ({ value }) => !!value
    }),
    ...metadataFields
  ],
  preview: {
    select: {
      translations: TRANSLATIONS_ARRAY_NAME,
      documentSchemaTypes: "schemaTypes"
    },
    prepare(selection) {
      const { translations = [], documentSchemaTypes = [] } = selection, title = translations.length === 1 ? "1 Translation" : `${translations.length} Translations`, languageKeys = translations.length ? translations.map((t) => t._key.toUpperCase()).join(", ") : "", subtitle = [
        languageKeys ? `(${languageKeys})` : null,
        documentSchemaTypes != null && documentSchemaTypes.length ? documentSchemaTypes.map((s) => s).join(", ") : ""
      ].filter(Boolean).join(" ");
      return {
        title,
        subtitle
      };
    }
  }
});
const documentInternationalization = definePlugin(
  (config) => {
    const pluginConfig = { ...DEFAULT_CONFIG, ...config }, {
      supportedLanguages,
      schemaTypes,
      languageField,
      bulkPublish,
      metadataFields
    } = pluginConfig;
    if (schemaTypes.length === 0)
      throw new Error(
        "You must specify at least one schema type on which to enable document internationalization. Update the `schemaTypes` option in the documentInternationalization() configuration."
      );
    return {
      name: "@sanity/document-internationalization",
      studio: {
        components: {
          layout: (props) => DocumentInternationalizationProvider({ ...props, pluginConfig })
        }
      },
      // Adds:
      // - A bulk-publishing UI component to the form
      // - Will only work for projects on a compatible plan
      form: {
        components: {
          input: (props) => {
            var _a, _b, _c;
            if (props.id === "root" && props.schemaType.name === METADATA_SCHEMA_NAME && isSanityDocument(props == null ? void 0 : props.value)) {
              const metadataId = (_a = props == null ? void 0 : props.value) == null ? void 0 : _a._id, translations = (_c = (_b = props == null ? void 0 : props.value) == null ? void 0 : _b.translations) != null ? _c : [], weakAndTypedTranslations = translations.filter(
                ({ value }) => (value == null ? void 0 : value._weak) && value._strengthenOnPublish
              );
              return /* @__PURE__ */ jsxs(Stack, { space: 5, children: [
                bulkPublish ? /* @__PURE__ */ jsx(BulkPublish, { translations }) : null,
                weakAndTypedTranslations.length > 0 ? /* @__PURE__ */ jsx(
                  OptimisticallyStrengthen,
                  {
                    metadataId,
                    translations: weakAndTypedTranslations
                  }
                ) : null,
                props.renderDefault(props)
              ] });
            }
            return props.renderDefault(props);
          }
        }
      },
      // Adds:
      // - The `Translations` dropdown to the editing form
      // - `Badges` to documents with a language value
      // - The `DeleteMetadataAction` action to the metadata document type
      document: {
        unstable_languageFilter: (prev, ctx) => {
          const { schemaType, documentId } = ctx;
          return schemaTypes.includes(schemaType) && documentId ? [
            ...prev,
            (props) => DocumentInternationalizationMenu({ ...props, documentId })
          ] : prev;
        },
        badges: (prev, { schemaType }) => schemaTypes.includes(schemaType) ? [(props) => LanguageBadge(props), ...prev] : prev,
        actions: (prev, { schemaType }) => schemaType === METADATA_SCHEMA_NAME ? [...prev, DeleteMetadataAction] : prev
      },
      // Adds:
      // - The `Translations metadata` document type to the schema
      schema: {
        // Create the metadata document type
        types: [metadata(schemaTypes, metadataFields)],
        // For every schema type this plugin is enabled on
        // Create an initial value template to set the language
        templates: (prev, { schema }) => {
          if (!Array.isArray(supportedLanguages))
            return prev;
          const parameterizedTemplates = schemaTypes.map((schemaType) => {
            var _a, _b;
            return {
              id: `${schemaType}-parameterized`,
              title: `${(_b = (_a = schema == null ? void 0 : schema.get(schemaType)) == null ? void 0 : _a.title) != null ? _b : schemaType}: with Language`,
              schemaType,
              parameters: [
                { name: "languageId", title: "Language ID", type: "string" }
              ],
              value: ({ languageId }) => ({
                [languageField]: languageId
              })
            };
          }), staticTemplates = schemaTypes.flatMap((schemaType) => supportedLanguages.map((language) => {
            var _a, _b;
            return {
              id: `${schemaType}-${language.id}`,
              title: `${language.title} ${(_b = (_a = schema == null ? void 0 : schema.get(schemaType)) == null ? void 0 : _a.title) != null ? _b : schemaType}`,
              schemaType,
              value: {
                [languageField]: language.id
              }
            };
          }));
          return [...prev, ...parameterizedTemplates, ...staticTemplates];
        }
      },
      // Uses:
      // - `sanity-plugin-internationalized-array` to maintain the translations array
      plugins: [
        // Translation metadata stores its references using this plugin
        // It cuts down on attribute usage and gives UI conveniences to add new translations
        internationalizedArray({
          languages: supportedLanguages,
          fieldTypes: [
            defineField(
              {
                name: "reference",
                type: "reference",
                to: schemaTypes.map((type) => ({ type })),
                weak: pluginConfig.weakReferences,
                // Reference filters don't actually enforce validation!
                validation: (Rule) => (
                  // @ts-expect-error - fix typings
                  Rule.custom(async (item, context) => {
                    var _a;
                    if (!((_a = item == null ? void 0 : item.value) != null && _a._ref) || !(item != null && item._key))
                      return !0;
                    const valueLanguage = await context.getClient({ apiVersion: API_VERSION }).fetch(
                      `*[_id in [$ref, $draftRef]][0].${languageField}`,
                      {
                        ref: item.value._ref,
                        draftRef: `drafts.${item.value._ref}`
                      }
                    );
                    return valueLanguage && valueLanguage === item._key ? !0 : "Referenced document does not have the correct language value";
                  })
                ),
                options: {
                  // @ts-expect-error - Update type once it knows the values of this filter
                  filter: ({ parent, document }) => {
                    if (!parent)
                      return null;
                    const language = (Array.isArray(parent) ? parent : [parent]).find((p) => p._key);
                    return language != null && language._key ? document.schemaTypes ? {
                      filter: `_type in $schemaTypes && ${languageField} == $language`,
                      params: {
                        schemaTypes: document.schemaTypes,
                        language: language._key
                      }
                    } : {
                      filter: `${languageField} == $language`,
                      params: { language: language._key }
                    } : null;
                  }
                }
              },
              { strict: !1 }
            )
          ]
        })
      ]
    };
  }
);
export {
  DeleteTranslationAction,
  DocumentInternationalizationMenu,
  documentInternationalization,
  useDocumentInternationalizationContext
};
//# sourceMappingURL=index.esm.js.map
