{"version":3,"file":"index.esm.js","sources":["../src/BaseDocumentMerger.ts","../src/BaseDocumentDeserializer/helpers.ts","../src/BaseSerializationConfig.ts","../src/BaseDocumentSerializer/fieldFilters.ts","../src/BaseDocumentSerializer/index.ts","../src/BaseDocumentDeserializer/BaseDocumentDeserializer.ts"],"sourcesContent":["import {Merger} from './types'\nimport {SanityDocument} from 'sanity'\nimport {extractWithPath, arrayToJSONMatchPath} from '@sanity/mutator'\n\nconst reconcileArray = (origArray: any[], translatedArray: any[]): any[] => {\n  //arrays of strings don't have keys, so just replace the array and return\n  if (translatedArray && translatedArray.some((el) => typeof el === 'string')) {\n    return translatedArray\n  }\n\n  //deep copy needed for field level patching\n  const combined = JSON.parse(JSON.stringify(origArray))\n\n  translatedArray.forEach((block) => {\n    if (!block._key) {\n      return\n    }\n    const foundBlockIdx = origArray.findIndex((origBlock) => origBlock._key === block._key)\n    if (foundBlockIdx < 0) {\n      //eslint-disable-next-line no-console\n      console.warn(\n        `This block no longer exists on the original document. Was it removed? ${JSON.stringify(\n          block\n        )}`\n      )\n    } else if (\n      origArray[foundBlockIdx]._type === 'block' ||\n      origArray[foundBlockIdx]._type === 'span'\n    ) {\n      combined[foundBlockIdx] = block\n    } else if (Array.isArray(origArray[foundBlockIdx])) {\n      combined[foundBlockIdx] = reconcileArray(origArray[foundBlockIdx], block)\n    } else {\n      //eslint-disable-next-line no-use-before-define -- this is a recursive function\n      combined[foundBlockIdx] = reconcileObject(origArray[foundBlockIdx], block)\n    }\n  })\n  return combined\n}\n\nconst reconcileObject = (\n  origObject: Record<string, any>,\n  translatedObject: Record<string, any>\n): Record<string, any> => {\n  if (typeof translatedObject !== 'object' || !Object.keys(translatedObject).length) {\n    return origObject\n  }\n\n  const updatedObj = JSON.parse(JSON.stringify(origObject))\n  Object.entries(translatedObject).forEach(([key, value]) => {\n    if (!value || key[0] === '_') {\n      return\n    }\n    if (typeof value === 'string') {\n      updatedObj[key] = value\n    } else if (Array.isArray(value)) {\n      //eslint-disable-next-line @typescript-eslint/no-use-before-define -- this is a recursive function\n      updatedObj[key] = reconcileArray(origObject[key] ?? [], value)\n    } else {\n      updatedObj[key] = reconcileObject(origObject[key] ?? {}, value)\n    }\n  })\n  return updatedObj\n}\n\nconst fieldLevelMerge = (\n  translatedFields: Record<string, any>,\n  //should be fetched according to the revision and id of the translated obj above\n  baseDoc: SanityDocument,\n  localeId: string,\n  baseLang: string = 'en'\n): Record<string, any> => {\n  const merged: Record<string, any> = {}\n  const metaKeys = ['_rev', '_id', '_type']\n  metaKeys.forEach((metaKey) => {\n    if (translatedFields[metaKey]) {\n      merged[metaKey] = translatedFields[metaKey]\n    }\n  })\n\n  //get any field that matches the base language, because it's been translated\n  const originPaths = extractWithPath(`..${baseLang}`, translatedFields)\n  originPaths.forEach((match) => {\n    const origVal = extractWithPath(arrayToJSONMatchPath(match.path), baseDoc)[0].value\n    const translatedVal = extractWithPath(arrayToJSONMatchPath(match.path), translatedFields)[0]\n      .value\n    let valToPatch\n    if (typeof translatedVal === 'string') {\n      valToPatch = translatedVal\n    } else if (Array.isArray(translatedVal) && translatedVal.length) {\n      valToPatch = reconcileArray((origVal as Array<any>) ?? [], translatedVal)\n    } else if (\n      typeof translatedVal === 'object' &&\n      Object.keys(translatedVal as Record<string, any>).length\n    ) {\n      valToPatch = reconcileObject(origVal ?? {}, translatedVal as Record<string, any>)\n    }\n    const destinationPath = [\n      ...match.path.slice(0, match.path.length - 1), //cut off the \"en\"\n      localeId.replace('-', '_'), // replace it with our locale\n    ]\n\n    merged[arrayToJSONMatchPath(destinationPath)] = valToPatch\n  })\n\n  return merged\n}\n\nconst documentLevelMerge = (\n  translatedFields: Record<string, any>,\n  //should be fetched according to the revision and id of the translated obj above\n  baseDoc: SanityDocument\n): Record<string, any> => {\n  return reconcileObject(baseDoc, translatedFields)\n}\n\nexport const BaseDocumentMerger: Merger = {\n  fieldLevelMerge,\n  documentLevelMerge,\n  reconcileArray,\n  reconcileObject,\n}\n","import {htmlToBlocks} from '@sanity/block-tools'\nimport {Schema} from '@sanity/schema'\nimport {ObjectField, PortableTextSpan, PortableTextTextBlock} from 'sanity'\n\nconst defaultSchema = Schema.compile({\n  name: 'default',\n  types: [\n    {\n      type: 'object',\n      name: 'default',\n      fields: [\n        {\n          name: 'block',\n          type: 'array',\n          of: [{type: 'block'}],\n        },\n      ],\n    },\n  ],\n})\n\nexport const blockContentType = defaultSchema\n  .get('default')\n  .fields.find((field: ObjectField) => field.name === 'block').type\n\nexport const noSchemaWarning = (obj: Element): string =>\n  `WARNING: Unfortunately the deserializer may have issues with this field or object: ${obj.className}.\n  If it's a specific type, you may need to declare  at the top level, or write a custom deserializer.`\n\n//helper to handle messy input -- take advantage\n//of blockTools' sanitizing behavior for single strings\nexport const preprocess = (html: string): string => {\n  const intermediateBlocks = htmlToBlocks(\n    `<p>${html}</p>`,\n    blockContentType\n  ) as PortableTextTextBlock<PortableTextSpan>[]\n  if (!intermediateBlocks.length) {\n    throw new Error(`Error parsing string '${html}'`)\n  }\n  return intermediateBlocks[0].children[0].text\n}\n","import {PortableTextBlockStyle} from '@portabletext/types'\n\nimport {\n  PortableTextBlockComponent,\n  PortableTextListComponent,\n  PortableTextListItemComponent,\n} from '@portabletext/to-html'\n\nimport {htmlToBlocks} from '@sanity/block-tools'\nimport {blockContentType} from './BaseDocumentDeserializer/helpers'\nimport {PortableTextTextBlock, TypedObject} from 'sanity'\n\nexport const defaultStopTypes = [\n  'reference',\n  'date',\n  'datetime',\n  'file',\n  'geopoint',\n  'image',\n  'number',\n  'crop',\n  'hotspot',\n  'boolean',\n  'url',\n  'color',\n  'code',\n]\n\nexport const defaultPortableTextBlockStyles: Record<\n  PortableTextBlockStyle,\n  PortableTextBlockComponent | undefined\n> = {\n  normal: ({value, children}) => `<p id=\"${value._key}\">${children}</p>`,\n  blockquote: ({value, children}) => `<blockquote id=\"${value._key}\">${children}</blockquote>`,\n  h1: ({value, children}) => `<h1 id=\"${value._key}\">${children}</h1>`,\n  h2: ({value, children}) => `<h2 id=\"${value._key}\">${children}</h2>`,\n  h3: ({value, children}) => `<h3 id=\"${value._key}\">${children}</h3>`,\n  h4: ({value, children}) => `<h4 id=\"${value._key}\">${children}</h4>`,\n  h5: ({value, children}) => `<h5 id=\"${value._key}\">${children}</h5>`,\n  h6: ({value, children}) => `<h6 id=\"${value._key}\">${children}</h6>`,\n}\n\nconst defaultLists: Record<'number' | 'bullet', PortableTextListComponent> = {\n  number: ({value, children}) => `<ol id=\"${value._key.replace('-parent', '')}\">${children}</ol>`,\n  bullet: ({value, children}) => `<ul id=\"${value._key.replace('-parent', '')}\">${children}</ul>`,\n}\n\nconst defaultListItem: PortableTextListItemComponent = ({value, children}) => {\n  const {_key, level} = value\n  return `<li id=\"${(_key || '').replace('-parent', '')}\" data-level=\"${level}\">${children}</li>`\n}\n\nconst unknownBlockFunc: PortableTextBlockComponent = ({value, children}) =>\n  `<p id=\"${value._key}\" data-type=\"unknown-block-style\" data-style=\"${value.style}\">${children}</p>`\n\nexport const customSerializers: Record<string, any> = {\n  unknownType: ({value}: {value: Record<string, any>}) => `<div class=\"${value._type}\"></div>`,\n  types: {},\n  block: defaultPortableTextBlockStyles,\n  list: defaultLists,\n  listItem: defaultListItem,\n  unknownBlockStyle: unknownBlockFunc,\n}\n\nexport const customDeserializers: Record<string, any> = {types: {}}\n\nexport const customBlockDeserializers: Array<any> = [\n  //handle undeclared styles\n  {\n    deserialize(\n      el: HTMLParagraphElement,\n      next: (elements: Node | Node[] | NodeList) => TypedObject | TypedObject[] | undefined\n    ): PortableTextTextBlock | TypedObject | undefined {\n      if (!el.hasChildNodes()) {\n        return undefined\n      }\n\n      if (el.getAttribute('data-type') !== 'unknown-block-style') {\n        return undefined\n      }\n\n      const style = el.getAttribute('data-style') ?? ''\n      const block = htmlToBlocks(el.outerHTML, blockContentType)[0]\n\n      return {\n        ...block,\n        style,\n        children: next(el.childNodes),\n      }\n    },\n  },\n  //handle list items\n  {\n    deserialize(\n      el: HTMLParagraphElement,\n      next: (elements: Node | Node[] | NodeList) => TypedObject | TypedObject[] | undefined\n    ): PortableTextTextBlock | TypedObject | undefined {\n      if (!el.hasChildNodes()) {\n        return undefined\n      }\n\n      if (el.tagName.toLowerCase() !== 'li') {\n        return undefined\n      }\n\n      const tagsToStyle: Record<string, string> = {\n        ul: 'bullet',\n        ol: 'number',\n      }\n\n      const parent = el.parentNode as HTMLUListElement | HTMLOListElement\n      if (!parent || !parent.tagName) {\n        return undefined\n      }\n\n      const listItem = tagsToStyle[parent.tagName.toLowerCase()]\n      if (!listItem) {\n        return undefined\n      }\n\n      const level =\n        el.getAttribute('data-level') && parseInt(el.getAttribute('data-level') || '0', 10)\n      const _key = el.id\n      let block = htmlToBlocks(parent.outerHTML, blockContentType)[0]\n      const customStyle = el.children?.[0]?.getAttribute('data-style')\n\n      //check if the object inside is also serialized -- that means it has a style\n      //or custom annotation and we should use childNode serialization\n      const regex = new RegExp(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/)\n      if (regex.test(el.innerHTML)) {\n        const newBlock = htmlToBlocks(el.innerHTML, blockContentType)[0]\n        if (newBlock) {\n          block = {\n            ...block,\n            ...newBlock,\n            style: customStyle ?? (newBlock as PortableTextTextBlock).style,\n          }\n\n          //next(childNodes) plays poorly with custom styles, issue to be filed.\n          if (customStyle) {\n            return block as PortableTextTextBlock\n          }\n        }\n      }\n\n      return {\n        ...block,\n        level,\n        _key,\n        listItem,\n        children: next(el.childNodes),\n      }\n    },\n  },\n]\n","import {ObjectField, TypedObject} from 'sanity'\n\nconst META_FIELDS = ['_key', '_type', '_id']\n\n/*\n * Helper. If field-level translation pattern used, only sends over\n * content from the base language. Works recursively, so if users\n * use this pattern several layers deep, base language fields will still be found.\n */\nexport const languageObjectFieldFilter = (\n  obj: Record<string, any>,\n  baseLang: string\n): Record<string, any> => {\n  const filterToLangField = (childObj: Record<string, any>) => {\n    const filteredObj: Record<string, any> = {}\n    filteredObj[baseLang] = childObj[baseLang]\n    META_FIELDS.forEach((field) => {\n      if (childObj[field]) {\n        filteredObj[field] = childObj[field]\n      }\n    })\n    return filteredObj\n  }\n\n  const findBaseLang = (childObj: Record<string, any>): Record<string, any> => {\n    const filteredObj: Record<string, any> = {}\n    META_FIELDS.forEach((field) => {\n      if (childObj[field]) {\n        filteredObj[field] = childObj[field]\n      }\n    })\n\n    for (const key in childObj) {\n      if (childObj.hasOwnProperty(key)) {\n        const value: any = childObj[key]\n        //we've reached a base language field, add it to\n        //what we want to send to translation\n        if (value.hasOwnProperty(baseLang)) {\n          filteredObj[key] = filterToLangField(value)\n        }\n        //we have an array that may have language fields in its objects\n        else if (Array.isArray(value) && value.length && typeof value[0] === 'object') {\n          //recursively find and filter for any objects that have the base language\n          const validLangObjects = value.reduce((validArr, objInArray) => {\n            if (objInArray._type === 'block') {\n              validArr.push(objInArray)\n            } else if (objInArray.hasOwnProperty(baseLang)) {\n              validArr.push(filterToLangField(objInArray))\n            } else {\n              const filtered = findBaseLang(objInArray)\n              const nonMetaFields = Object.keys(filtered).filter(\n                (objInArrayKey) => META_FIELDS.indexOf(objInArrayKey) === -1\n              )\n              if (nonMetaFields.length) {\n                validArr.push(filtered)\n              }\n            }\n            return validArr\n          }, [])\n          if (validLangObjects.length) {\n            filteredObj[key] = validLangObjects\n          }\n        }\n        //we have an object nested in an object\n        //recurse down the tree\n        else if (typeof value === 'object') {\n          const nestedLangObj = findBaseLang(value)\n          const nonMetaFields = Object.keys(nestedLangObj).filter(\n            (nestedObjKey) => META_FIELDS.indexOf(nestedObjKey) === -1\n          )\n          if (nonMetaFields.length) {\n            filteredObj[key] = nestedLangObj\n          }\n        }\n      }\n    }\n    return filteredObj\n  }\n\n  //send top level object into recursive function\n  return findBaseLang(obj)\n}\n\n/*\n * Eliminates stop-types and non-localizable fields\n * for document-level translation.\n */\nexport const fieldFilter = (\n  obj: Record<string, any>,\n  objFields: ObjectField[],\n  stopTypes: string[]\n): TypedObject => {\n  const filteredObj: TypedObject = {_type: obj._type}\n\n  const fieldFilterFunc = (field: Record<string, any>) => {\n    if (field.localize === false) {\n      return false\n    } else if (field.type === 'string' || field.type === 'text') {\n      return true\n    } else if (Array.isArray(obj[field.name])) {\n      return true\n    } else if (!stopTypes.includes(field.type)) {\n      return true\n    }\n    return false\n  }\n\n  const validFields = [\n    ...META_FIELDS,\n    ...objFields?.filter(fieldFilterFunc)?.map((field) => field.name),\n  ]\n  validFields.forEach((field) => {\n    if (obj[field]) {\n      filteredObj[field] = obj[field]\n    }\n  })\n  return filteredObj\n}\n","import {defaultStopTypes, customSerializers} from '../BaseSerializationConfig'\nimport {SanityDocument, TypedObject, Schema} from 'sanity'\nimport {TranslationLevel, SerializerClosure} from '../types'\nimport {fieldFilter, languageObjectFieldFilter} from './fieldFilters'\nimport {PortableTextTypeComponent, toHTML} from '@portabletext/to-html'\n\nconst META_FIELDS = ['_key', '_type', '_id', '_weak']\n\nexport const BaseDocumentSerializer: SerializerClosure = (schemas: Schema) => {\n  /*\n   * Helper function that allows us to get metadata (like `localize: false`) from schema fields.\n   */\n  const getSchema = (name: string) => schemas?._original?.types.find((s) => s.name === name) as any\n\n  const serializeObject = (\n    obj: TypedObject,\n    stopTypes: string[],\n    serializers: Record<string, any>\n  ) => {\n    if (stopTypes.includes(obj._type)) {\n      return ''\n    }\n\n    //if user has declared a custom serializer, use that\n    //instead of this method\n    const hasSerializer = serializers.types && Object.keys(serializers.types).includes(obj._type)\n    if (hasSerializer) {\n      return toHTML([obj], {components: serializers})\n    }\n\n    //we don't need to worry about PT types\n    if (obj._type === 'span' || obj._type === 'block') {\n      return toHTML(obj, {components: serializers})\n    }\n\n    //if schema is available, encode values in the order they're declared in the schema,\n    //since this will likely be more intuitive for a translator.\n    let fieldNames = Object.keys(obj).filter((key) => key !== '_type')\n    const schema = getSchema(obj._type)\n    if (schema && schema.fields) {\n      fieldNames = schema.fields\n        .map((field: Record<string, any>) => field.name)\n        .filter((schemaKey: string) => Object.keys(obj).includes(schemaKey))\n    }\n\n    //account for anonymous inline objects\n    if (typeof obj === 'object' && !obj._type) {\n      obj._type = ''\n    }\n\n    //in some cases, we might recurse through many objects of the same type\n    //we should take all methods necessary to ensure state does not persist\n    //otherwise we risk using old serialization methods on new items\n    const newSerializationMethods: Record<string, PortableTextTypeComponent> = {}\n    const tempType = `${obj._type}__temp_type__${Math.random().toString(36).substring(7)}`\n    const objToSerialize: TypedObject = {_type: tempType}\n    //for our default serialization method, we only need to\n    //capture metadata. the rest will be recursively turned into strings.\n    META_FIELDS.filter((f) => f !== '_type').forEach((field) => {\n      objToSerialize[field] = obj[field]\n    })\n\n    let innerHTML = ''\n\n    //if it's a custom object, iterate through its keys to find and serialize translatable content\n    fieldNames.forEach((fieldName) => {\n      let htmlField = ''\n\n      if (!META_FIELDS.includes(fieldName)) {\n        const value = obj[fieldName]\n        //strings are either string fields or have recursively been turned\n        //into HTML because they were a nested object or array\n        if (typeof value === 'string') {\n          const htmlRegex = new RegExp(/<(\"[^\"]*\"|'[^']*'|[^'\">])*>/)\n          if (htmlRegex.test(value)) {\n            htmlField = value\n          } else {\n            htmlField = `<span class=\"${fieldName}\">${value}</span>`\n          }\n        }\n\n        //array fields get filtered and its children serialized\n        else if (Array.isArray(value)) {\n          //eslint-disable-next-line no-use-before-define -- this is a recursive function\n          htmlField = serializeArray(value, fieldName, stopTypes, {\n            ...serializers,\n            types: {...serializers.types},\n          })\n        }\n\n        //this is an object in an object, serialize it first\n        else {\n          const embeddedObject = value as TypedObject\n          const embeddedObjectSchema = getSchema(embeddedObject._type)\n          let toTranslate = embeddedObject\n          if (embeddedObjectSchema && embeddedObjectSchema.fields) {\n            toTranslate = fieldFilter(toTranslate, embeddedObjectSchema.fields, stopTypes)\n          }\n          const objHTML = serializeObject(toTranslate, stopTypes, {\n            ...serializers,\n            types: {...serializers.types},\n          })\n          htmlField = `<div class=\"${fieldName}\" data-level=\"field\">${objHTML}</div>`\n        }\n\n        innerHTML += htmlField\n      }\n    })\n\n    if (!innerHTML) {\n      return ''\n    }\n\n    newSerializationMethods[tempType] = ({value}: {value: TypedObject}) => {\n      let div = `<div class=\"${value._type.split('__temp_type__')[0]}\"`\n      if (value._key || value._id) {\n        div += `id=\"${value._key ?? value._id}\"`\n      }\n\n      return [div, ` data-type=\"object\">${innerHTML}</div>`].join('')\n    }\n\n    let serializedBlock = ''\n    try {\n      serializedBlock = toHTML(objToSerialize, {\n        components: {\n          ...serializers,\n          types: {\n            ...serializers.types,\n            ...newSerializationMethods,\n          },\n        },\n      })\n    } catch (err) {\n      //eslint-disable-next-line no-console -- this is a warning\n      console.warn(\n        `Had issues serializing block of type \"${obj._type}\". Please specify a serialization method for this block in your serialization config. Received error: ${err}`\n      )\n    }\n\n    return serializedBlock\n  }\n\n  const serializeArray = (\n    fieldContent: Record<string, any>[],\n    fieldName: string,\n    stopTypes: string[],\n    serializers: Record<string, any>\n  ) => {\n    //filter for any blocks that user has indicated\n    //should not be sent for translation\n    const validBlocks = fieldContent.filter((block) => !stopTypes.includes(block._type))\n\n    //take out any fields in these blocks that should\n    //not be sent to translation\n    const filteredBlocks = validBlocks.map((block) => {\n      const schema = getSchema(block._type)\n      if (schema && schema.fields) {\n        return fieldFilter(block, schema.fields, stopTypes)\n      }\n      return block\n    })\n\n    const output = filteredBlocks.map((obj) => {\n      //if object in array is just a string, just return it\n      if (typeof obj === 'string') {\n        return `<span>${obj}</span>`\n      }\n      //send to serialization method\n      return serializeObject(obj as TypedObject, stopTypes, serializers)\n    })\n\n    //encode this with data-level field\n    return `<div class=\"${fieldName}\" data-type=\"array\">${output.join('')}</div>`\n  }\n\n  /*\n   * Main parent function: finds fields to translate, and feeds them to appropriate child serialization\n   * methods.\n   */\n  const serializeDocument = (\n    doc: SanityDocument,\n    translationLevel: TranslationLevel = 'document',\n    baseLang = 'en',\n    stopTypes = defaultStopTypes,\n    serializers = customSerializers\n  ) => {\n    const schema = getSchema(doc._type)\n    let filteredObj: Record<string, any> = {}\n\n    //field level translations explicitly send over any fields that\n    //match the base language, regardless of depth\n    if (translationLevel === 'field') {\n      filteredObj = languageObjectFieldFilter(doc, baseLang)\n    }\n    //otherwise, we can refer to the schema and a list of stop types\n    //to determine what should not be sent\n    else {\n      filteredObj = fieldFilter(doc, schema.fields, stopTypes)\n    }\n\n    const serializedFields: Record<string, any> = {}\n\n    for (const key in filteredObj) {\n      if (filteredObj.hasOwnProperty(key) === false) continue\n      const value: Record<string, any> | Array<any> | string = filteredObj[key]\n\n      if (typeof value === 'string') {\n        serializedFields[key] = value\n      } else if (Array.isArray(value)) {\n        serializedFields[key] = serializeArray(value, key, stopTypes, serializers)\n      } else if (value && !stopTypes.find((stopType) => stopType == value?._type)) {\n        const serialized = serializeObject(value as TypedObject, stopTypes, serializers)\n        serializedFields[key] = `<div class=\"${key}\" data-level='field'>${serialized}</div>`\n      }\n    }\n\n    //create a valid HTML file\n    const rawHTMLBody = document.createElement('body')\n    rawHTMLBody.innerHTML = serializeObject(serializedFields as TypedObject, stopTypes, serializers)\n\n    const rawHTMLHead = document.createElement('head')\n    const metaFields = ['_id', '_type', '_rev']\n    //save our metadata as meta tags so we can use them later on\n    metaFields.forEach((field) => {\n      const metaEl = document.createElement('meta')\n      metaEl.setAttribute('name', field)\n      metaEl.setAttribute('content', doc[field] as string)\n      rawHTMLHead.appendChild(metaEl)\n    })\n    //encode version so we can use the correct deserialization methods\n    const versionMeta = document.createElement('meta')\n    versionMeta.setAttribute('name', 'version')\n    versionMeta.setAttribute('content', '3')\n    rawHTMLHead.appendChild(versionMeta)\n\n    const rawHTML = document.createElement('html')\n    rawHTML.appendChild(rawHTMLHead)\n    rawHTML.appendChild(rawHTMLBody)\n\n    return {\n      name: doc._id,\n      content: rawHTML.outerHTML,\n    }\n  }\n\n  return {\n    serializeDocument,\n    fieldFilter,\n    languageObjectFieldFilter,\n    serializeArray,\n    serializeObject,\n  }\n}\n","// import {htmlToBlocks} from '@sanity/block-tools'\nimport {htmlToBlocks} from '@sanity/block-tools'\nimport {customDeserializers, customBlockDeserializers} from '../BaseSerializationConfig'\nimport {Deserializer} from '../types'\nimport {blockContentType, preprocess} from './helpers'\n\nconst deserializeArray = (\n  arrayHTML: Element,\n  deserializers: Record<string, any> = customDeserializers,\n  blockDeserializers = customBlockDeserializers\n) => {\n  const output: any[] = []\n  const children = Array.from(arrayHTML.children)\n  children.forEach((child) => {\n    let deserializedObject: any\n    try {\n      if (child.tagName?.toLowerCase() === 'span') {\n        deserializedObject = preprocess(child.innerHTML)\n      }\n      //has specific class name or data type, so it's an obj\n      else if (child.className || child.getAttribute('data-type') === 'object') {\n        //eslint-disable-next-line no-use-before-define -- this is a recursive function\n        deserializedObject = deserializeObject(child, deserializers, blockDeserializers)\n        deserializedObject._key = child.id\n      } else {\n        deserializedObject = htmlToBlocks(child.outerHTML, blockContentType, {\n          rules: blockDeserializers,\n        })[0]\n        deserializedObject._key = child.id\n      }\n    } catch (e) {\n      //eslint-disable-next-line no-console\n      console.debug(\n        `Tried to deserialize block: ${child.outerHTML} in an array but failed to identify it! Error: ${e}`\n      )\n    }\n    output.push(deserializedObject)\n  })\n  return output\n}\n\nconst deserializeObject = (\n  objectHTML: Element,\n  deserializers: Record<string, any> = customDeserializers,\n  blockDeserializers = customBlockDeserializers\n) => {\n  const deserialize = deserializers.types[objectHTML.className]\n  if (deserialize) {\n    return deserialize(objectHTML)\n  }\n\n  const output: Record<string, any> = {}\n  //account for anonymous inline objects\n  if (objectHTML.className) {\n    output._type = objectHTML.className\n  }\n  const children = Array.from(objectHTML.children)\n\n  children.forEach((child) => {\n    //string field\n    if (child.tagName?.toLowerCase() === 'span') {\n      output[child.className] = preprocess(child.innerHTML)\n    }\n    //richer field, either object or array\n    else if (child.getAttribute('data-level') === 'field') {\n      //eslint-disable-next-line no-use-before-define -- this is a recursive function\n      const deserialized = deserializeHTML(child.outerHTML, deserializers, blockDeserializers)\n      if (deserialized && Object.keys(deserialized).length) {\n        output[child.className] = deserialized\n      } else {\n        //eslint-disable-next-line no-console\n        console.debug(`Deserializer: Skipping empty or unreadable HTML: ${child.outerHTML}`)\n      }\n    } else if (child.getAttribute('data-type') === 'array') {\n      output[child.className] = deserializeArray(child, deserializers, blockDeserializers)\n    }\n  })\n  return output\n}\n\nconst deserializeHTML = (\n  html: string,\n  deserializers: Record<string, any>,\n  blockDeserializers: Array<any>\n): Record<string, any> | any[] => {\n  //parent node is always div with classname of field -- get its child\n  let HTMLnode = new DOMParser().parseFromString(html, 'text/html').body.children[0]\n\n  //catch embedded object as a field\n  if (HTMLnode?.getAttribute('data-level') === 'field') {\n    HTMLnode = HTMLnode.children[0]\n  }\n\n  if (!HTMLnode) {\n    return {}\n  }\n\n  let output: Record<string, any> | any[]\n\n  //prioritize custom deserialization\n  const deserialize = deserializers.types[HTMLnode.className]\n  if (deserialize) {\n    output = deserialize(HTMLnode)\n  } else if (HTMLnode.getAttribute('data-type') === 'object') {\n    output = deserializeObject(HTMLnode, deserializers, blockDeserializers)\n  } else if (HTMLnode.getAttribute('data-type') === 'array') {\n    output = deserializeArray(HTMLnode, deserializers, blockDeserializers)\n  } else {\n    output = {}\n    //eslint-disable-next-line no-console\n    console.debug(`Tried to deserialize block ${HTMLnode.outerHTML} but failed to identify it!`)\n  }\n\n  return output\n}\n\nconst deserializeDocument = (\n  serializedDoc: string,\n  deserializers: Record<string, any> = customDeserializers,\n  blockDeserializers = customBlockDeserializers\n): Record<string, any> => {\n  const metadata: Record<string, any> = {}\n  const head = new DOMParser().parseFromString(serializedDoc, 'text/html').head\n\n  Array.from(head.children).forEach((metaTag) => {\n    const validTags = ['_id', '_rev', '_type']\n    const metaName = metaTag.getAttribute('name')\n    if (metaName && validTags.includes(metaName)) {\n      metadata[metaName] = metaTag.getAttribute('content')\n    }\n  })\n\n  const content: Record<string, any> = deserializeHTML(\n    serializedDoc,\n    deserializers,\n    blockDeserializers\n  )\n\n  return {\n    ...content,\n    ...metadata,\n  }\n}\n\nexport const BaseDocumentDeserializer: Deserializer = {\n  deserializeDocument,\n  deserializeHTML,\n}\n"],"names":["reconcileArray","origArray","translatedArray","some","el","combined","JSON","parse","stringify","forEach","block","_key","foundBlockIdx","findIndex","origBlock","console","warn","concat","_type","Array","isArray","reconcileObject","origObject","translatedObject","Object","keys","length","updatedObj","entries","_ref","key","value","_a","_b","fieldLevelMerge","translatedFields","baseDoc","localeId","baseLang","merged","metaKeys","metaKey","originPaths","extractWithPath","match","origVal","arrayToJSONMatchPath","path","translatedVal","valToPatch","destinationPath","slice","replace","documentLevelMerge","BaseDocumentMerger","defaultSchema","Schema","compile","name","types","type","fields","of","blockContentType","get","find","field","preprocess","html","intermediateBlocks","htmlToBlocks","Error","children","text","defaultStopTypes","defaultPortableTextBlockStyles","normal","_ref2","blockquote","_ref3","h1","_ref4","h2","_ref5","h3","_ref6","h4","_ref7","h5","_ref8","h6","_ref9","defaultLists","number","_ref10","bullet","_ref11","defaultListItem","_ref12","level","unknownBlockFunc","_ref13","style","customSerializers","unknownType","_ref14","list","listItem","unknownBlockStyle","customDeserializers","customBlockDeserializers","deserialize","next","hasChildNodes","getAttribute","outerHTML","childNodes","tagName","toLowerCase","tagsToStyle","ul","ol","parent","parentNode","parseInt","id","customStyle","regex","RegExp","test","innerHTML","newBlock","META_FIELDS","languageObjectFieldFilter","obj","filterToLangField","childObj","filteredObj","findBaseLang","hasOwnProperty","validLangObjects","reduce","validArr","objInArray","push","filtered","nonMetaFields","filter","objInArrayKey","indexOf","nestedLangObj","nestedObjKey","fieldFilter","objFields","stopTypes","fieldFilterFunc","localize","includes","validFields","map","BaseDocumentSerializer","schemas","getSchema","_original","s","serializeObject","serializers","hasSerializer","toHTML","components","fieldNames","schema","schemaKey","newSerializationMethods","tempType","Math","random","toString","substring","objToSerialize","f","fieldName","htmlField","htmlRegex","serializeArray","embeddedObject","embeddedObjectSchema","toTranslate","objHTML","_ref15","div","split","_id","join","serializedBlock","err","fieldContent","validBlocks","filteredBlocks","output","serializeDocument","doc","translationLevel","arguments","undefined","serializedFields","stopType","serialized","rawHTMLBody","document","createElement","rawHTMLHead","metaFields","metaEl","setAttribute","appendChild","versionMeta","rawHTML","content","deserializeArray","arrayHTML","deserializers","blockDeserializers","from","child","deserializedObject","className","deserializeObject","rules","e","debug","objectHTML","deserialized","deserializeHTML","HTMLnode","DOMParser","parseFromString","body","deserializeDocument","serializedDoc","metadata","head","metaTag","validTags","metaName","BaseDocumentDeserializer"],"mappings":";;;;AAIA,MAAMA,cAAA,GAAiBA,CAACC,SAAA,EAAkBC,eAAkC,KAAA;EAEtE,IAAAA,eAAA,IAAmBA,gBAAgBC,IAAK,CAACC,MAAO,OAAOA,EAAA,KAAO,QAAQ,CAAG,EAAA;IACpE,OAAAF,eAAA;EACT;EAGA,MAAMG,WAAWC,IAAK,CAAAC,KAAA,CAAMD,IAAK,CAAAE,SAAA,CAAUP,SAAS,CAAC,CAAA;EAErCC,eAAA,CAAAO,OAAA,CAASC,KAAU,IAAA;IAC7B,IAAA,CAACA,MAAMC,IAAM,EAAA;MACf;IACF;IACM,MAAAC,aAAA,GAAgBX,UAAUY,SAAU,CAACC,aAAcA,SAAU,CAAAH,IAAA,KAASD,MAAMC,IAAI,CAAA;IACtF,IAAIC,gBAAgB,CAAG,EAAA;MAEbG,OAAA,CAAAC,IAAA,0EAAAC,MAAA,CACmEX,IAAK,CAAAE,SAAA,CAC5EE,KAAA,CACF,CAAA,CACF;IAAA,CACF,MAAA,IACET,SAAU,CAAAW,aAAa,CAAE,CAAAM,KAAA,KAAU,WACnCjB,SAAU,CAAAW,aAAa,CAAE,CAAAM,KAAA,KAAU,MACnC,EAAA;MACAb,QAAA,CAASO,aAAa,CAAI,GAAAF,KAAA;eACjBS,KAAM,CAAAC,OAAA,CAAQnB,SAAU,CAAAW,aAAa,CAAC,CAAG,EAAA;MAClDP,QAAA,CAASO,aAAa,CAAI,GAAAZ,cAAA,CAAeC,SAAU,CAAAW,aAAa,GAAGF,KAAK,CAAA;IAAA,CACnE,MAAA;MAELL,QAAA,CAASO,aAAa,CAAI,GAAAS,eAAA,CAAgBpB,SAAU,CAAAW,aAAa,GAAGF,KAAK,CAAA;IAC3E;EAAA,CACD,CAAA;EACM,OAAAL,QAAA;AACT,CAAA;AAEA,MAAMgB,eAAA,GAAkBA,CACtBC,UAAA,EACAC,gBACwB,KAAA;EACpB,IAAA,OAAOA,qBAAqB,QAAY,IAAA,CAACC,OAAOC,IAAK,CAAAF,gBAAgB,EAAEG,MAAQ,EAAA;IAC1E,OAAAJ,UAAA;EACT;EAEA,MAAMK,aAAarB,IAAK,CAAAC,KAAA,CAAMD,IAAK,CAAAE,SAAA,CAAUc,UAAU,CAAC,CAAA;EACjDE,MAAA,CAAAI,OAAA,CAAQL,gBAAgB,CAAE,CAAAd,OAAA,CAAQoB,IAAA,IAAkB;IAAA,IAAjB,CAACC,GAAA,EAAKC,KAAK,CAAM,GAAAF,IAAA;IAjD7D,IAAAG,EAAA,EAAAC,EAAA;IAkDI,IAAI,CAACF,KAAA,IAASD,GAAI,CAAA,CAAC,MAAM,GAAK,EAAA;MAC5B;IACF;IACI,IAAA,OAAOC,UAAU,QAAU,EAAA;MAC7BJ,UAAA,CAAWG,GAAG,CAAI,GAAAC,KAAA;IACT,CAAA,MAAA,IAAAZ,KAAA,CAAMC,OAAQ,CAAAW,KAAK,CAAG,EAAA;MAEpBJ,UAAA,CAAAG,GAAG,IAAI9B,cAAe,CAAA,CAAAgC,EAAA,GAAAV,UAAA,CAAWQ,GAAG,CAAd,KAAA,IAAA,GAAAE,EAAA,GAAmB,EAAC,EAAGD,KAAK,CAAA;IAAA,CACxD,MAAA;MACMJ,UAAA,CAAAG,GAAG,IAAIT,eAAgB,CAAA,CAAAY,EAAA,GAAAX,UAAA,CAAWQ,GAAG,CAAd,KAAA,IAAA,GAAAG,EAAA,GAAmB,CAAC,CAAA,EAAGF,KAAK,CAAA;IAChE;EAAA,CACD,CAAA;EACM,OAAAJ,UAAA;AACT,CAAA;AAEA,MAAMO,kBAAkB,SAAAA,CACtBC,gBAAA,EAEAC,OACA,EAAAC,QAAA,EAEwB;EAAA,IADxBC,+EAAmB,IACK;EACxB,MAAMC,SAA8B,CAAA,CAAC;EACrC,MAAMC,QAAW,GAAA,CAAC,MAAQ,EAAA,KAAA,EAAO,OAAO,CAAA;EAC/BA,QAAA,CAAA/B,OAAA,CAASgC,OAAY,IAAA;IACxB,IAAAN,gBAAA,CAAiBM,OAAO,CAAG,EAAA;MACtBF,MAAA,CAAAE,OAAO,CAAI,GAAAN,gBAAA,CAAiBM,OAAO,CAAA;IAC5C;EAAA,CACD,CAAA;EAGD,MAAMC,WAAc,GAAAC,eAAA,MAAA1B,MAAA,CAAqBqB,QAAA,GAAYH,gBAAgB,CAAA;EACzDO,WAAA,CAAAjC,OAAA,CAASmC,KAAU,IAAA;IACvB,MAAAC,OAAA,GAAUF,gBAAgBG,oBAAqB,CAAAF,KAAA,CAAMG,IAAI,CAAG,EAAAX,OAAO,CAAE,CAAA,CAAC,CAAE,CAAAL,KAAA;IACxE,MAAAiB,aAAA,GAAgBL,gBAAgBG,oBAAqB,CAAAF,KAAA,CAAMG,IAAI,CAAG,EAAAZ,gBAAgB,CAAE,CAAA,CAAC,CACxF,CAAAJ,KAAA;IACC,IAAAkB,UAAA;IACA,IAAA,OAAOD,kBAAkB,QAAU,EAAA;MACxBC,UAAA,GAAAD,aAAA;IAAA,WACJ7B,KAAM,CAAAC,OAAA,CAAQ4B,aAAa,CAAA,IAAKA,cAActB,MAAQ,EAAA;MAC/DuB,UAAA,GAAajD,cAAgB,CAAA6C,OAAA,IAAA,IAAA,GAAAA,OAAA,GAA0B,EAAC,EAAGG,aAAa,CAAA;IAAA,CAC1E,MAAA,IACE,OAAOA,aAAkB,KAAA,QAAA,IACzBxB,OAAOC,IAAK,CAAAuB,aAAoC,EAAEtB,MAClD,EAAA;MACAuB,UAAA,GAAa5B,eAAgB,CAAAwB,OAAA,IAAA,IAAA,GAAAA,OAAA,GAAW,CAAA,CAAC,EAAGG,aAAoC,CAAA;IAClF;IACA,MAAME,eAAkB,GAAA,CACtB,GAAGN,MAAMG,IAAK,CAAAI,KAAA,CAAM,GAAGP,KAAM,CAAAG,IAAA,CAAKrB,SAAS,CAAC,CAAA;IAAA;IAC5CW,QAAA,CAASe,OAAQ,CAAA,GAAA,EAAK,GAAG;IAAA;IAAA,CAC3B;;IAEOb,MAAA,CAAAO,oBAAA,CAAqBI,eAAe,CAAC,CAAI,GAAAD,UAAA;EAAA,CACjD,CAAA;EAEM,OAAAV,MAAA;AACT,CAAA;AAEA,MAAMc,kBAAA,GAAqBA,CACzBlB,gBAAA,EAEAC,OACwB,KAAA;EACjB,OAAAf,eAAA,CAAgBe,SAASD,gBAAgB,CAAA;AAClD,CAAA;AAEO,MAAMmB,kBAA6B,GAAA;EACxCpB,eAAA;EACAmB,kBAAA;EACArD,cAAA;EACAqB;AACF,CAAA;ACrHA,MAAMkC,aAAA,GAAgBC,OAAOC,OAAQ,CAAA;EACnCC,IAAM,EAAA,SAAA;EACNC,KAAO,EAAA,CACL;IACEC,IAAM,EAAA,QAAA;IACNF,IAAM,EAAA,SAAA;IACNG,MAAQ,EAAA,CACN;MACEH,IAAM,EAAA,OAAA;MACNE,IAAM,EAAA,OAAA;MACNE,EAAI,EAAA,CAAC;QAACF,IAAA,EAAM;OAAQ;IACtB,CAAA;EAEJ,CAAA;AAEJ,CAAC,CAAA;AAEM,MAAMG,gBAAmB,GAAAR,aAAA,CAC7BS,GAAI,CAAA,SAAS,CACb,CAAAH,MAAA,CAAOI,IAAK,CAACC,KAAuB,IAAAA,KAAA,CAAMR,IAAS,KAAA,OAAO,CAAE,CAAAE,IAAA;AAQlD,MAAAO,UAAA,GAAcC,IAAyB,IAAA;EAClD,MAAMC,kBAAqB,GAAAC,YAAA,OAAArD,MAAA,CACnBmD,IAAA,WACNL,gBAAA,CACF;EACI,IAAA,CAACM,mBAAmB3C,MAAQ,EAAA;IACxB,MAAA,IAAI6C,KAAM,0BAAAtD,MAAA,CAAyBmD,IAAO,MAAA,CAAA;EAClD;EACA,OAAOC,kBAAmB,CAAA,CAAC,CAAE,CAAAG,QAAA,CAAS,CAAC,CAAE,CAAAC,IAAA;AAC3C,CAAA;AC5BO,MAAMC,gBAAmB,GAAA,CAC9B,WAAA,EACA,MAAA,EACA,UAAA,EACA,MAAA,EACA,UAAA,EACA,OAAA,EACA,QAAA,EACA,MAAA,EACA,SAAA,EACA,SAAA,EACA,KAAA,EACA,OAAA,EACA,MAAA,CACF;AAEO,MAAMC,8BAGT,GAAA;EACFC,MAAA,EAAQC,KAAA;IAAA,IAAC;MAAC9C,KAAA;MAAOyC;KAAc,GAAAK,KAAA;IAAA,kBAAA5D,MAAA,CAAUc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACxDM,UAAA,EAAYC,KAAA;IAAA,IAAC;MAAChD,KAAA;MAAOyC;KAAc,GAAAO,KAAA;IAAA,2BAAA9D,MAAA,CAAmBc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrEQ,EAAA,EAAIC,KAAA;IAAA,IAAC;MAAClD,KAAA;MAAOyC;KAAc,GAAAS,KAAA;IAAA,mBAAAhE,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrDU,EAAA,EAAIC,KAAA;IAAA,IAAC;MAACpD,KAAA;MAAOyC;KAAc,GAAAW,KAAA;IAAA,mBAAAlE,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrDY,EAAA,EAAIC,KAAA;IAAA,IAAC;MAACtD,KAAA;MAAOyC;KAAc,GAAAa,KAAA;IAAA,mBAAApE,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrDc,EAAA,EAAIC,KAAA;IAAA,IAAC;MAACxD,KAAA;MAAOyC;KAAc,GAAAe,KAAA;IAAA,mBAAAtE,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrDgB,EAAA,EAAIC,KAAA;IAAA,IAAC;MAAC1D,KAAA;MAAOyC;KAAc,GAAAiB,KAAA;IAAA,mBAAAxE,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA,CAAA;EACrDkB,EAAA,EAAIC,KAAA;IAAA,IAAC;MAAC5D,KAAA;MAAOyC;KAAc,GAAAmB,KAAA;IAAA,mBAAA1E,MAAA,CAAWc,MAAMpB,IAAS,SAAAM,MAAA,CAAAuD,QAAA;EAAA;AACvD,CAAA;AAEA,MAAMoB,YAAuE,GAAA;EAC3EC,MAAQ,EAAAC,MAAA;IAAA,IAAC;MAAC/D,KAAA;MAAOyC;IAAQ,CAAA,GAAAsB,MAAA;IAAA,mBAAA7E,MAAA,CAAiBc,KAAA,CAAMpB,IAAK,CAAAyC,OAAA,CAAQ,SAAW,EAAA,EAAE,CAAM,SAAAnC,MAAA,CAAAuD,QAAA;EAAA,CAAA;EAChFuB,MAAQ,EAAAC,MAAA;IAAA,IAAC;MAACjE,KAAA;MAAOyC;IAAQ,CAAA,GAAAwB,MAAA;IAAA,mBAAA/E,MAAA,CAAiBc,KAAA,CAAMpB,IAAK,CAAAyC,OAAA,CAAQ,SAAW,EAAA,EAAE,CAAM,SAAAnC,MAAA,CAAAuD,QAAA;EAAA;AAClF,CAAA;AAEA,MAAMyB,eAAiD,GAAAC,MAAA,IAAuB;EAAA,IAAtB;IAACnE,KAAA;IAAOyC;GAAc,GAAA0B,MAAA;EACtE,MAAA;IAACvF,IAAM;IAAAwF;EAAS,CAAA,GAAApE,KAAA;EACtB,mBAAAd,MAAA,EAAmBN,IAAQ,IAAA,EAAA,EAAIyC,QAAQ,SAAW,EAAA,EAAE,8BAAkB+C,KAAU,SAAAlF,MAAA,CAAAuD,QAAA;AAClF,CAAA;AAEA,MAAM4B,gBAAA,GAA+CC,MAAA;EAAA,IAAC;IAACtE,KAAO;IAAAyC;EAAA;2BAClDzC,KAAA,CAAMpB,IAAqD,wDAAAM,MAAA,CAAAc,KAAA,CAAMuE,KAAU,SAAArF,MAAA,CAAAuD,QAAA;AAAA,CAAA;AAEhF,MAAM+B,iBAAyC,GAAA;EACpDC,aAAaC,MAAA;IAAA,IAAC;MAAC1E;IAAK,CAAA,GAAA0E,MAAA;IAAA,uBAAAxF,MAAA,CAAmDc,KAAM,CAAAb,KAAA;EAAA,CAAA;EAC7EyC,OAAO,CAAC,CAAA;EACRjD,KAAO,EAAAiE,8BAAA;EACP+B,IAAM,EAAAd,YAAA;EACNe,QAAU,EAAAV,eAAA;EACVW,iBAAmB,EAAAR;AACrB,CAAA;AAEO,MAAMS,mBAA2C,GAAA;EAAClD,KAAO,EAAA,CAAA;CAAE;AAE3D,MAAMmD,wBAAuC,GAAA;AAAA;AAElD;EACEC,WAAAA,CACE3G,IACA4G,IACiD,EAAA;IAxEvD,IAAAhF,EAAA;IAyEU,IAAA,CAAC5B,EAAG,CAAA6G,aAAA,EAAiB,EAAA;MAChB,OAAA,KAAA,CAAA;IACT;IAEA,IAAI7G,EAAG,CAAA8G,YAAA,CAAa,WAAW,CAAA,KAAM,qBAAuB,EAAA;MACnD,OAAA,KAAA,CAAA;IACT;IAEA,MAAMZ,KAAQ,GAAA,CAAAtE,EAAA,GAAA5B,EAAA,CAAG8G,YAAa,CAAA,YAAY,MAA5B,IAAiC,GAAAlF,EAAA,GAAA,EAAA;IAC/C,MAAMtB,QAAQ4D,YAAa,CAAAlE,EAAA,CAAG+G,SAAW,EAAApD,gBAAgB,EAAE,CAAC,CAAA;IAErD,OAAA;MACL,GAAGrD,KAAA;MACH4F,KAAA;MACA9B,QAAA,EAAUwC,IAAK,CAAA5G,EAAA,CAAGgH,UAAU;IAAA,CAC9B;EACF;AACF,CAAA;AAAA;AAEA;EACEL,WAAAA,CACE3G,IACA4G,IACiD,EAAA;IAhGvD,IAAAhF,EAAA,EAAAC,EAAA;IAiGU,IAAA,CAAC7B,EAAG,CAAA6G,aAAA,EAAiB,EAAA;MAChB,OAAA,KAAA,CAAA;IACT;IAEA,IAAI7G,EAAG,CAAAiH,OAAA,CAAQC,WAAY,CAAA,CAAA,KAAM,IAAM,EAAA;MAC9B,OAAA,KAAA,CAAA;IACT;IAEA,MAAMC,WAAsC,GAAA;MAC1CC,EAAI,EAAA,QAAA;MACJC,EAAI,EAAA;IAAA,CACN;IAEA,MAAMC,SAAStH,EAAG,CAAAuH,UAAA;IAClB,IAAI,CAACD,MAAA,IAAU,CAACA,MAAA,CAAOL,OAAS,EAAA;MACvB,OAAA,KAAA,CAAA;IACT;IAEA,MAAMV,QAAW,GAAAY,WAAA,CAAYG,MAAO,CAAAL,OAAA,CAAQC,YAAa,CAAA,CAAA;IACzD,IAAI,CAACX,QAAU,EAAA;MACN,OAAA,KAAA,CAAA;IACT;IAEM,MAAAR,KAAA,GACJ/F,EAAG,CAAA8G,YAAA,CAAa,YAAY,CAAA,IAAKU,QAAS,CAAAxH,EAAA,CAAG8G,YAAa,CAAA,YAAY,CAAK,IAAA,GAAA,EAAK,EAAE,CAAA;IACpF,MAAMvG,OAAOP,EAAG,CAAAyH,EAAA;IAChB,IAAInH,QAAQ4D,YAAa,CAAAoD,MAAA,CAAOP,SAAW,EAAApD,gBAAgB,EAAE,CAAC,CAAA;IAC9D,MAAM+D,eAAc7F,EAAG,GAAA,CAAAD,EAAA,GAAA5B,EAAA,CAAAoE,QAAA,KAAH,IAAc,GAAA,KAAA,CAAA,GAAAxC,EAAA,CAAA,CAAA,CAAA,KAAd,mBAAkBkF,YAAa,CAAA,YAAA,CAAA;IAI7C,MAAAa,KAAA,GAAQ,IAAIC,MAAA,CAAO,6BAA6B,CAAA;IACtD,IAAID,KAAM,CAAAE,IAAA,CAAK7H,EAAG,CAAA8H,SAAS,CAAG,EAAA;MAC5B,MAAMC,WAAW7D,YAAa,CAAAlE,EAAA,CAAG8H,SAAW,EAAAnE,gBAAgB,EAAE,CAAC,CAAA;MAC/D,IAAIoE,QAAU,EAAA;QACJzH,KAAA,GAAA;UACN,GAAGA,KAAA;UACH,GAAGyH,QAAA;UACH7B,KAAA,EAAOwB,oCAAgBK,QAAmC,CAAA7B;QAAA,CAC5D;QAGA,IAAIwB,WAAa,EAAA;UACR,OAAApH,KAAA;QACT;MACF;IACF;IAEO,OAAA;MACL,GAAGA,KAAA;MACHyF,KAAA;MACAxF,IAAA;MACAgG,QAAA;MACAnC,QAAA,EAAUwC,IAAK,CAAA5G,EAAA,CAAGgH,UAAU;IAAA,CAC9B;EACF;AACF,CAAA,CACF;ACxJA,MAAMgB,aAAc,GAAA,CAAC,MAAQ,EAAA,OAAA,EAAS,KAAK,CAAA;AAO9B,MAAAC,yBAAA,GAA4BA,CACvCC,GAAA,EACAhG,QACwB,KAAA;EAClB,MAAAiG,iBAAA,GAAqBC,QAAkC,IAAA;IAC3D,MAAMC,cAAmC,CAAA,CAAC;IAC9BA,WAAA,CAAAnG,QAAQ,CAAI,GAAAkG,QAAA,CAASlG,QAAQ,CAAA;IAC7B8F,aAAA,CAAA3H,OAAA,CAASyD,KAAU,IAAA;MACzB,IAAAsE,QAAA,CAAStE,KAAK,CAAG,EAAA;QACPuE,WAAA,CAAAvE,KAAK,CAAI,GAAAsE,QAAA,CAAStE,KAAK,CAAA;MACrC;IAAA,CACD,CAAA;IACM,OAAAuE,WAAA;EAAA,CACT;EAEM,MAAAC,YAAA,GAAgBF,QAAuD,IAAA;IAC3E,MAAMC,cAAmC,CAAA,CAAC;IAC9BL,aAAA,CAAA3H,OAAA,CAASyD,KAAU,IAAA;MACzB,IAAAsE,QAAA,CAAStE,KAAK,CAAG,EAAA;QACPuE,WAAA,CAAAvE,KAAK,CAAI,GAAAsE,QAAA,CAAStE,KAAK,CAAA;MACrC;IAAA,CACD,CAAA;IAED,KAAA,MAAWpC,OAAO0G,QAAU,EAAA;MACtB,IAAAA,QAAA,CAASG,cAAe,CAAA7G,GAAG,CAAG,EAAA;QAC1B,MAAAC,KAAA,GAAayG,SAAS1G,GAAG,CAAA;QAG3B,IAAAC,KAAA,CAAM4G,cAAe,CAAArG,QAAQ,CAAG,EAAA;UACtBmG,WAAA,CAAA3G,GAAG,CAAI,GAAAyG,iBAAA,CAAkBxG,KAAK,CAAA;QAC5C,CAAA,MAAA,IAESZ,KAAM,CAAAC,OAAA,CAAQW,KAAK,CAAA,IAAKA,KAAM,CAAAL,MAAA,IAAU,OAAOK,KAAA,CAAM,CAAC,CAAA,KAAM,QAAU,EAAA;UAE7E,MAAM6G,gBAAmB,GAAA7G,KAAA,CAAM8G,MAAO,CAAA,CAACC,UAAUC,UAAe,KAAA;YAC1D,IAAAA,UAAA,CAAW7H,UAAU,OAAS,EAAA;cAChC4H,QAAA,CAASE,KAAKD,UAAU,CAAA;YACf,CAAA,MAAA,IAAAA,UAAA,CAAWJ,cAAe,CAAArG,QAAQ,CAAG,EAAA;cACrCwG,QAAA,CAAAE,IAAA,CAAKT,iBAAkB,CAAAQ,UAAU,CAAC,CAAA;YAAA,CACtC,MAAA;cACC,MAAAE,QAAA,GAAWP,aAAaK,UAAU,CAAA;cACxC,MAAMG,aAAgB,GAAA1H,MAAA,CAAOC,IAAK,CAAAwH,QAAQ,CAAE,CAAAE,MAAA,CACzCC,aAAA,IAAkBhB,aAAY,CAAAiB,OAAA,CAAQD,aAAa,CAAM,KAAA,CAAA,CAAA,CAC5D;cACA,IAAIF,cAAcxH,MAAQ,EAAA;gBACxBoH,QAAA,CAASE,KAAKC,QAAQ,CAAA;cACxB;YACF;YACO,OAAAH,QAAA;UACT,CAAA,EAAG,EAAE,CAAA;UACL,IAAIF,iBAAiBlH,MAAQ,EAAA;YAC3B+G,WAAA,CAAY3G,GAAG,CAAI,GAAA8G,gBAAA;UACrB;QAAA,CACF,MAAA,IAGS,OAAO7G,KAAA,KAAU,QAAU,EAAA;UAC5B,MAAAuH,aAAA,GAAgBZ,aAAa3G,KAAK,CAAA;UACxC,MAAMmH,aAAgB,GAAA1H,MAAA,CAAOC,IAAK,CAAA6H,aAAa,CAAE,CAAAH,MAAA,CAC9CI,YAAA,IAAiBnB,aAAY,CAAAiB,OAAA,CAAQE,YAAY,CAAM,KAAA,CAAA,CAAA,CAC1D;UACA,IAAIL,cAAcxH,MAAQ,EAAA;YACxB+G,WAAA,CAAY3G,GAAG,CAAI,GAAAwH,aAAA;UACrB;QACF;MACF;IACF;IACO,OAAAb,WAAA;EAAA,CACT;EAGA,OAAOC,aAAaJ,GAAG,CAAA;AACzB,CAAA;AAMO,MAAMkB,WAAc,GAAAA,CACzBlB,GACA,EAAAmB,SAAA,EACAC,SACgB,KAAA;EA3FlB,IAAA1H,EAAA;EA4FE,MAAMyG,WAA2B,GAAA;IAACvH,KAAO,EAAAoH,GAAA,CAAIpH;EAAK,CAAA;EAE5C,MAAAyI,eAAA,GAAmBzF,KAA+B,IAAA;IAClD,IAAAA,KAAA,CAAM0F,aAAa,KAAO,EAAA;MACrB,OAAA,KAAA;IAAA,WACE1F,KAAM,CAAAN,IAAA,KAAS,QAAY,IAAAM,KAAA,CAAMN,SAAS,MAAQ,EAAA;MACpD,OAAA,IAAA;IAAA,WACEzC,KAAM,CAAAC,OAAA,CAAQkH,IAAIpE,KAAM,CAAAR,IAAI,CAAC,CAAG,EAAA;MAClC,OAAA,IAAA;eACE,CAACgG,SAAA,CAAUG,QAAS,CAAA3F,KAAA,CAAMN,IAAI,CAAG,EAAA;MACnC,OAAA,IAAA;IACT;IACO,OAAA,KAAA;EAAA,CACT;EAEA,MAAMkG,WAAc,GAAA,CAClB,GAAG1B,aAAA,EACH,IAAA,CAAGpG,4CAAWmH,MAAO,CAAAQ,eAAA,CAAA,KAAlB,mBAAoCI,GAAI,CAAC7F,SAAUA,KAAM,CAAAR,IAAA,CAAA,EAC9D;EACYoG,WAAA,CAAArJ,OAAA,CAASyD,KAAU,IAAA;IACzB,IAAAoE,GAAA,CAAIpE,KAAK,CAAG,EAAA;MACFuE,WAAA,CAAAvE,KAAK,CAAI,GAAAoE,GAAA,CAAIpE,KAAK,CAAA;IAChC;EAAA,CACD,CAAA;EACM,OAAAuE,WAAA;AACT,CAAA;AC/GA,MAAML,WAAc,GAAA,CAAC,MAAQ,EAAA,OAAA,EAAS,OAAO,OAAO,CAAA;AAEvC,MAAA4B,sBAAA,GAA6CC,OAAoB,IAAA;EAItE,MAAAC,SAAA,GAAaxG,IAAc,IAAA;IAZnC,IAAA1B,EAAA;IAYsC,OAAA,CAAAA,EAAA,GAAAiI,OAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,OAAA,CAASE,cAAT,IAAoB,GAAA,KAAA,CAAA,GAAAnI,EAAA,CAAA2B,KAAA,CAAMM,KAAMmG,CAAA,IAAMA,EAAE1G,IAAS,KAAAA,IAAA,CAAA;EAAA,CAAA;EAErF,MAAM2G,eAAkB,GAAAA,CACtB/B,GACA,EAAAoB,SAAA,EACAY,WACG,KAAA;IACH,IAAIZ,SAAU,CAAAG,QAAA,CAASvB,GAAI,CAAApH,KAAK,CAAG,EAAA;MAC1B,OAAA,EAAA;IACT;IAIM,MAAAqJ,aAAA,GAAgBD,WAAY,CAAA3G,KAAA,IAASnC,MAAO,CAAAC,IAAA,CAAK6I,YAAY3G,KAAK,CAAA,CAAEkG,QAAS,CAAAvB,GAAA,CAAIpH,KAAK,CAAA;IAC5F,IAAIqJ,aAAe,EAAA;MACjB,OAAOC,OAAO,CAAClC,GAAG,GAAG;QAACmC,UAAA,EAAYH;OAAY,CAAA;IAChD;IAGA,IAAIhC,GAAI,CAAApH,KAAA,KAAU,MAAU,IAAAoH,GAAA,CAAIpH,UAAU,OAAS,EAAA;MACjD,OAAOsJ,MAAO,CAAAlC,GAAA,EAAK;QAACmC,UAAA,EAAYH;MAAY,CAAA,CAAA;IAC9C;IAII,IAAAI,UAAA,GAAalJ,OAAOC,IAAK,CAAA6G,GAAG,EAAEa,MAAO,CAACrH,GAAQ,IAAAA,GAAA,KAAQ,OAAO,CAAA;IAC3D,MAAA6I,MAAA,GAAST,SAAU,CAAA5B,GAAA,CAAIpH,KAAK,CAAA;IAC9B,IAAAyJ,MAAA,IAAUA,OAAO9G,MAAQ,EAAA;MAC3B6G,UAAA,GAAaC,OAAO9G,MACjB,CAAAkG,GAAA,CAAK7F,KAAA,IAA+BA,MAAMR,IAAI,CAAA,CAC9CyF,MAAO,CAACyB,aAAsBpJ,MAAO,CAAAC,IAAA,CAAK6G,GAAG,CAAE,CAAAuB,QAAA,CAASe,SAAS,CAAC,CAAA;IACvE;IAGA,IAAI,OAAOtC,GAAA,KAAQ,QAAY,IAAA,CAACA,IAAIpH,KAAO,EAAA;MACzCoH,GAAA,CAAIpH,KAAQ,GAAA,EAAA;IACd;IAKA,MAAM2J,0BAAqE,CAAA,CAAC;IACtE,MAAAC,QAAA,MAAA7J,MAAA,CAAcqH,GAAA,CAAIpH,KAAqB,mBAAAD,MAAA,CAAA8J,IAAA,CAAKC,MAAO,CAAA,CAAA,CAAEC,QAAS,CAAA,EAAE,CAAE,CAAAC,SAAA,CAAU,CAAC,CAAA,CAAA;IAC7E,MAAAC,cAAA,GAA8B;MAACjK,KAAA,EAAO4J;KAAQ;IAGxC1C,WAAA,CAAAe,MAAA,CAAQiC,CAAM,IAAAA,CAAA,KAAM,OAAO,CAAE,CAAA3K,OAAA,CAASyD,KAAU,IAAA;MAC3CiH,cAAA,CAAAjH,KAAK,CAAI,GAAAoE,GAAA,CAAIpE,KAAK,CAAA;IAAA,CAClC,CAAA;IAED,IAAIgE,SAAY,GAAA,EAAA;IAGLwC,UAAA,CAAAjK,OAAA,CAAS4K,SAAc,IAAA;MAChC,IAAIC,SAAY,GAAA,EAAA;MAEhB,IAAI,CAAClD,WAAA,CAAYyB,QAAS,CAAAwB,SAAS,CAAG,EAAA;QAC9B,MAAAtJ,KAAA,GAAQuG,IAAI+C,SAAS,CAAA;QAGvB,IAAA,OAAOtJ,UAAU,QAAU,EAAA;UACvB,MAAAwJ,SAAA,GAAY,IAAIvD,MAAA,CAAO,6BAA6B,CAAA;UACtD,IAAAuD,SAAA,CAAUtD,IAAK,CAAAlG,KAAK,CAAG,EAAA;YACbuJ,SAAA,GAAAvJ,KAAA;UAAA,CACP,MAAA;YACLuJ,SAAA,oBAAArK,MAAA,CAA4BoK,SAAc,SAAApK,MAAA,CAAAc,KAAA,YAAA;UAC5C;QAIO,CAAA,MAAA,IAAAZ,KAAA,CAAMC,OAAQ,CAAAW,KAAK,CAAG,EAAA;UAEjBuJ,SAAA,GAAAE,cAAA,CAAezJ,KAAO,EAAAsJ,SAAA,EAAW3B,SAAW,EAAA;YACtD,GAAGY,WAAA;YACH3G,KAAO,EAAA;cAAC,GAAG2G,WAAA,CAAY3G;YAAK;UAAA,CAC7B,CAAA;QAAA,CAIE,MAAA;UACH,MAAM8H,cAAiB,GAAA1J,KAAA;UACjB,MAAA2J,oBAAA,GAAuBxB,SAAU,CAAAuB,cAAA,CAAevK,KAAK,CAAA;UAC3D,IAAIyK,WAAc,GAAAF,cAAA;UACd,IAAAC,oBAAA,IAAwBA,qBAAqB7H,MAAQ,EAAA;YACvD8H,WAAA,GAAcnC,WAAY,CAAAmC,WAAA,EAAaD,oBAAqB,CAAA7H,MAAA,EAAQ6F,SAAS,CAAA;UAC/E;UACM,MAAAkC,OAAA,GAAUvB,eAAgB,CAAAsB,WAAA,EAAajC,SAAW,EAAA;YACtD,GAAGY,WAAA;YACH3G,KAAO,EAAA;cAAC,GAAG2G,WAAA,CAAY3G;YAAK;UAAA,CAC7B,CAAA;UACD2H,SAAA,mBAAArK,MAAA,CAA2BoK,SAAiC,8BAAApK,MAAA,CAAA2K,OAAA,WAAA;QAC9D;QAEa1D,SAAA,IAAAoD,SAAA;MACf;IAAA,CACD,CAAA;IAED,IAAI,CAACpD,SAAW,EAAA;MACP,OAAA,EAAA;IACT;IAEA2C,uBAAA,CAAwBC,QAAQ,CAAA,GAAIe,MAAA,IAAmC;MAAA,IAAlC;QAAC9J;OAAiC,GAAA8J,MAAA;MAjH3E,IAAA7J,EAAA;MAkHM,IAAI8J,6BAAqB/J,KAAA,CAAMb,MAAM6K,KAAM,CAAA,eAAe,EAAE,CAAC,CAAA,OAAA;MACzD,IAAAhK,KAAA,CAAMpB,IAAQ,IAAAoB,KAAA,CAAMiK,GAAK,EAAA;QAC3BF,GAAA,YAAA7K,MAAA,CAAc,CAAAe,EAAA,GAAAD,KAAA,CAAMpB,IAAN,KAAA,IAAA,GAAAqB,EAAA,GAAcD,KAAM,CAAAiK,GAAA,OAAA;MACpC;MAEA,OAAO,CAACF,GAAK,2BAAA7K,MAAA,CAAuBiH,SAAiB,YAAA,CAAE+D,KAAK,EAAE,CAAA;IAAA,CAChE;IAEA,IAAIC,eAAkB,GAAA,EAAA;IAClB,IAAA;MACFA,eAAA,GAAkB1B,OAAOW,cAAgB,EAAA;QACvCV,UAAY,EAAA;UACV,GAAGH,WAAA;UACH3G,KAAO,EAAA;YACL,GAAG2G,WAAY,CAAA3G,KAAA;YACf,GAAGkH;UACL;QACF;MAAA,CACD,CAAA;aACMsB,GAAP,EAAA;MAEQpL,OAAA,CAAAC,IAAA,2CAAAC,MAAA,CACmCqH,IAAIpH,KAA8G,6GAAAD,MAAA,CAAAkL,GAAA,CAAA,CAC7J;IACF;IAEO,OAAAD,eAAA;EAAA,CACT;EAEA,MAAMV,cAAiB,GAAAA,CACrBY,YACA,EAAAf,SAAA,EACA3B,WACAY,WACG,KAAA;IAGG,MAAA+B,WAAA,GAAcD,YAAa,CAAAjD,MAAA,CAAQzI,KAAA,IAAU,CAACgJ,SAAU,CAAAG,QAAA,CAASnJ,KAAM,CAAAQ,KAAK,CAAC,CAAA;IAInF,MAAMoL,cAAiB,GAAAD,WAAA,CAAYtC,GAAI,CAACrJ,KAAU,IAAA;MAC1C,MAAAiK,MAAA,GAAST,SAAU,CAAAxJ,KAAA,CAAMQ,KAAK,CAAA;MAChC,IAAAyJ,MAAA,IAAUA,OAAO9G,MAAQ,EAAA;QAC3B,OAAO2F,WAAY,CAAA9I,KAAA,EAAOiK,MAAO,CAAA9G,MAAA,EAAQ6F,SAAS,CAAA;MACpD;MACO,OAAAhJ,KAAA;IAAA,CACR,CAAA;IAED,MAAM6L,MAAS,GAAAD,cAAA,CAAevC,GAAI,CAACzB,GAAQ,IAAA;MAErC,IAAA,OAAOA,QAAQ,QAAU,EAAA;QAC3B,gBAAArH,MAAA,CAAgBqH,GAAA;MAClB;MAEO,OAAA+B,eAAA,CAAgB/B,GAAoB,EAAAoB,SAAA,EAAWY,WAAW,CAAA;IAAA,CAClE,CAAA;IAGD,uBAAArJ,MAAA,CAAsBoK,SAAA,6BAAApK,MAAA,CAAgCsL,MAAO,CAAAN,IAAA,CAAK,EAAE,CAAA;EAAA,CACtE;EAMM,MAAAO,iBAAA,GAAoB,SAAAA,CACxBC,GAAA,EAKG;IAAA,IAJHC,gBAAqC,GAAAC,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAA,UAAA;IAAA,IACrCrK,+EAAW,IACX;IAAA,IAAAoH,SAAA,GAAAiD,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAYjI,gBACZ;IAAA,IAAA4F,WAAA,GAAAqC,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAcpG,iBACX;IACG,MAAAoE,MAAA,GAAST,SAAU,CAAAuC,GAAA,CAAIvL,KAAK,CAAA;IAClC,IAAIuH,cAAmC,CAAA,CAAC;IAIxC,IAAIiE,qBAAqB,OAAS,EAAA;MAClBjE,WAAA,GAAAJ,yBAAA,CAA0BoE,KAAKnK,QAAQ,CAAA;IAAA,CAIlD,MAAA;MACHmG,WAAA,GAAce,WAAY,CAAAiD,GAAA,EAAK9B,MAAO,CAAA9G,MAAA,EAAQ6F,SAAS,CAAA;IACzD;IAEA,MAAMmD,mBAAwC,CAAA,CAAC;IAE/C,KAAA,MAAW/K,OAAO2G,WAAa,EAAA;MACzB,IAAAA,WAAA,CAAYE,cAAe,CAAA7G,GAAG,CAAM,KAAA,KAAA,EAAO;MACzC,MAAAC,KAAA,GAAmD0G,YAAY3G,GAAG,CAAA;MAEpE,IAAA,OAAOC,UAAU,QAAU,EAAA;QAC7B8K,gBAAA,CAAiB/K,GAAG,CAAI,GAAAC,KAAA;MACf,CAAA,MAAA,IAAAZ,KAAA,CAAMC,OAAQ,CAAAW,KAAK,CAAG,EAAA;QAC/B8K,gBAAA,CAAiB/K,GAAG,CAAI,GAAA0J,cAAA,CAAezJ,KAAO,EAAAD,GAAA,EAAK4H,WAAWY,WAAW,CAAA;MAC3E,CAAA,MAAA,IAAWvI,KAAS,IAAA,CAAC2H,SAAU,CAAAzF,IAAA,CAAM6I,QAAa,IAAAA,QAAA,KAAY/K,KAAO,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,KAAA,CAAAb,KAAA,CAAK,CAAG,EAAA;QAC3E,MAAM6L,UAAa,GAAA1C,eAAA,CAAgBtI,KAAsB,EAAA2H,SAAA,EAAWY,WAAW,CAAA;QAC9DuC,gBAAA,CAAA/K,GAAG,CAAI,mBAAAb,MAAA,CAAea,GAA2B,4BAAAb,MAAA,CAAA8L,UAAA,WAAA;MACpE;IACF;IAGM,MAAAC,WAAA,GAAcC,QAAS,CAAAC,aAAA,CAAc,MAAM,CAAA;IACjDF,WAAA,CAAY9E,SAAY,GAAAmC,eAAA,CAAgBwC,gBAAiC,EAAAnD,SAAA,EAAWY,WAAW,CAAA;IAEzF,MAAA6C,WAAA,GAAcF,QAAS,CAAAC,aAAA,CAAc,MAAM,CAAA;IACjD,MAAME,UAAa,GAAA,CAAC,KAAO,EAAA,OAAA,EAAS,MAAM,CAAA;IAE/BA,UAAA,CAAA3M,OAAA,CAASyD,KAAU,IAAA;MACtB,MAAAmJ,MAAA,GAASJ,QAAS,CAAAC,aAAA,CAAc,MAAM,CAAA;MACrCG,MAAA,CAAAC,YAAA,CAAa,QAAQpJ,KAAK,CAAA;MACjCmJ,MAAA,CAAOC,YAAa,CAAA,SAAA,EAAWb,GAAI,CAAAvI,KAAK,CAAW,CAAA;MACnDiJ,WAAA,CAAYI,YAAYF,MAAM,CAAA;IAAA,CAC/B,CAAA;IAEK,MAAAG,WAAA,GAAcP,QAAS,CAAAC,aAAA,CAAc,MAAM,CAAA;IACrCM,WAAA,CAAAF,YAAA,CAAa,QAAQ,SAAS,CAAA;IAC9BE,WAAA,CAAAF,YAAA,CAAa,WAAW,GAAG,CAAA;IACvCH,WAAA,CAAYI,YAAYC,WAAW,CAAA;IAE7B,MAAAC,OAAA,GAAUR,QAAS,CAAAC,aAAA,CAAc,MAAM,CAAA;IAC7CO,OAAA,CAAQF,YAAYJ,WAAW,CAAA;IAC/BM,OAAA,CAAQF,YAAYP,WAAW,CAAA;IAExB,OAAA;MACLtJ,MAAM+I,GAAI,CAAAT,GAAA;MACV0B,SAASD,OAAQ,CAAAtG;IAAA,CACnB;EAAA,CACF;EAEO,OAAA;IACLqF,iBAAA;IACAhD,WAAA;IACAnB,yBAAA;IACAmD,cAAA;IACAnB;EAAA,CACF;AACF,CAAA;ACvPA,MAAMsD,mBAAmB,SAAAA,CACvBC,SAAA,EAGG;EAAA,IAFHC,aAAqC,GAAAlB,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAA9F,mBAAA;EAAA,IACrCiH,yFAAqBhH,wBAClB;EACH,MAAMyF,SAAgB,EAAC;EACvB,MAAM/H,QAAW,GAAArD,KAAA,CAAM4M,IAAK,CAAAH,SAAA,CAAUpJ,QAAQ,CAAA;EACrCA,QAAA,CAAA/D,OAAA,CAASuN,KAAU,IAAA;IAb9B,IAAAhM,EAAA;IAcQ,IAAAiM,kBAAA;IACA,IAAA;MACF,IAAA,CAAA,CAAIjM,EAAM,GAAAgM,KAAA,CAAA3G,OAAA,KAAN,IAAe,GAAA,KAAA,CAAA,GAAArF,EAAA,CAAAsF,WAAA,CAAA,CAAA,MAAkB,MAAQ,EAAA;QACtB2G,kBAAA,GAAA9J,UAAA,CAAW6J,MAAM9F,SAAS,CAAA;MAAA,WAGxC8F,KAAM,CAAAE,SAAA,IAAaF,MAAM9G,YAAa,CAAA,WAAW,MAAM,QAAU,EAAA;QAEnD+G,kBAAA,GAAAE,iBAAA,CAAkBH,KAAO,EAAAH,aAAA,EAAeC,kBAAkB,CAAA;QAC/EG,kBAAA,CAAmBtN,OAAOqN,KAAM,CAAAnG,EAAA;MAAA,CAC3B,MAAA;QACgBoG,kBAAA,GAAA3J,YAAA,CAAa0J,KAAM,CAAA7G,SAAA,EAAWpD,gBAAkB,EAAA;UACnEqK,KAAO,EAAAN;QAAA,CACR,EAAE,CAAC,CAAA;QACJG,kBAAA,CAAmBtN,OAAOqN,KAAM,CAAAnG,EAAA;MAClC;aACOwG,CAAP,EAAA;MAEQtN,OAAA,CAAAuN,KAAA,gCAAArN,MAAA,CACyB+M,MAAM7G,SAA2D,qDAAAlG,MAAA,CAAAoN,CAAA,CAAA,CAClG;IACF;IACA9B,MAAA,CAAOvD,KAAKiF,kBAAkB,CAAA;EAAA,CAC/B,CAAA;EACM,OAAA1B,MAAA;AACT,CAAA;AAEA,MAAM4B,oBAAoB,SAAAA,CACxBI,UAAA,EAGG;EAAA,IAFHV,aAAqC,GAAAlB,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAA9F,mBAAA;EAAA,IACrCiH,yFAAqBhH,wBAClB;EACH,MAAMC,WAAc,GAAA8G,aAAA,CAAclK,KAAM,CAAA4K,UAAA,CAAWL,SAAS,CAAA;EAC5D,IAAInH,WAAa,EAAA;IACf,OAAOA,YAAYwH,UAAU,CAAA;EAC/B;EAEA,MAAMhC,SAA8B,CAAA,CAAC;EAErC,IAAIgC,WAAWL,SAAW,EAAA;IACxB3B,MAAA,CAAOrL,QAAQqN,UAAW,CAAAL,SAAA;EAC5B;EACA,MAAM1J,QAAW,GAAArD,KAAA,CAAM4M,IAAK,CAAAQ,UAAA,CAAW/J,QAAQ,CAAA;EAEtCA,QAAA,CAAA/D,OAAA,CAASuN,KAAU,IAAA;IA1D9B,IAAAhM,EAAA;IA4DI,IAAA,CAAA,CAAIA,EAAM,GAAAgM,KAAA,CAAA3G,OAAA,KAAN,IAAe,GAAA,KAAA,CAAA,GAAArF,EAAA,CAAAsF,WAAA,CAAA,CAAA,MAAkB,MAAQ,EAAA;MAC3CiF,MAAA,CAAOyB,KAAM,CAAAE,SAAS,CAAI,GAAA/J,UAAA,CAAW6J,MAAM9F,SAAS,CAAA;IAG7C,CAAA,MAAA,IAAA8F,KAAA,CAAM9G,YAAa,CAAA,YAAY,MAAM,OAAS,EAAA;MAErD,MAAMsH,YAAe,GAAAC,eAAA,CAAgBT,KAAM,CAAA7G,SAAA,EAAW0G,eAAeC,kBAAkB,CAAA;MACvF,IAAIU,YAAgB,IAAAhN,MAAA,CAAOC,IAAK,CAAA+M,YAAY,EAAE9M,MAAQ,EAAA;QAC7C6K,MAAA,CAAAyB,KAAA,CAAME,SAAS,CAAI,GAAAM,YAAA;MAAA,CACrB,MAAA;QAEGzN,OAAA,CAAAuN,KAAA,qDAAArN,MAAA,CAA0D+M,KAAA,CAAM7G,SAAW,CAAA,CAAA;MACrF;IACS,CAAA,MAAA,IAAA6G,KAAA,CAAM9G,YAAa,CAAA,WAAW,MAAM,OAAS,EAAA;MACtDqF,MAAA,CAAOyB,MAAME,SAAS,CAAA,GAAIP,gBAAiB,CAAAK,KAAA,EAAOH,eAAeC,kBAAkB,CAAA;IACrF;EAAA,CACD,CAAA;EACM,OAAAvB,MAAA;AACT,CAAA;AAEA,MAAMkC,eAAkB,GAAAA,CACtBrK,IACA,EAAAyJ,aAAA,EACAC,kBACgC,KAAA;EAE5B,IAAAY,QAAA,GAAW,IAAIC,SAAA,CAAY,CAAA,CAAAC,eAAA,CAAgBxK,MAAM,WAAW,CAAA,CAAEyK,IAAK,CAAArK,QAAA,CAAS,CAAC,CAAA;EAG7E,IAAA,CAAAkK,QAAA,IAAA,IAAA,GAAA,KAAA,CAAA,GAAAA,QAAA,CAAUxH,YAAa,CAAA,YAAA,CAAA,MAAkB,OAAS,EAAA;IACzCwH,QAAA,GAAAA,QAAA,CAASlK,SAAS,CAAC,CAAA;EAChC;EAEA,IAAI,CAACkK,QAAU,EAAA;IACb,OAAO,EAAC;EACV;EAEI,IAAAnC,MAAA;EAGJ,MAAMxF,WAAc,GAAA8G,aAAA,CAAclK,KAAM,CAAA+K,QAAA,CAASR,SAAS,CAAA;EAC1D,IAAInH,WAAa,EAAA;IACfwF,MAAA,GAASxF,YAAY2H,QAAQ,CAAA;EACpB,CAAA,MAAA,IAAAA,QAAA,CAASxH,YAAa,CAAA,WAAW,MAAM,QAAU,EAAA;IACjDqF,MAAA,GAAA4B,iBAAA,CAAkBO,QAAU,EAAAb,aAAA,EAAeC,kBAAkB,CAAA;EAC7D,CAAA,MAAA,IAAAY,QAAA,CAASxH,YAAa,CAAA,WAAW,MAAM,OAAS,EAAA;IAChDqF,MAAA,GAAAoB,gBAAA,CAAiBe,QAAU,EAAAb,aAAA,EAAeC,kBAAkB,CAAA;EAAA,CAChE,MAAA;IACLvB,MAAA,GAAS,CAAA,CAAC;IAEFxL,OAAA,CAAAuN,KAAA,+BAAArN,MAAA,CAAoCyN,QAAA,CAASvH,SAAsC,gCAAA,CAAA;EAC7F;EAEO,OAAAoF,MAAA;AACT,CAAA;AAEA,MAAMuC,sBAAsB,SAAAA,CAC1BC,aAAA,EAGwB;EAAA,IAFxBlB,aAAqC,GAAAlB,SAAA,CAAAjL,MAAA,QAAAiL,SAAA,QAAAC,SAAA,GAAAD,SAAA,MAAA9F,mBAAA;EAAA,IACrCiH,yFAAqBhH,wBACG;EACxB,MAAMkI,WAAgC,CAAA,CAAC;EACvC,MAAMC,OAAO,IAAIN,SAAA,GAAYC,eAAgB,CAAAG,aAAA,EAAe,WAAW,CAAE,CAAAE,IAAA;EAEzE9N,KAAA,CAAM4M,KAAKkB,IAAK,CAAAzK,QAAQ,CAAE,CAAA/D,OAAA,CAASyO,OAAY,IAAA;IAC7C,MAAMC,SAAY,GAAA,CAAC,KAAO,EAAA,MAAA,EAAQ,OAAO,CAAA;IACnC,MAAAC,QAAA,GAAWF,OAAQ,CAAAhI,YAAA,CAAa,MAAM,CAAA;IAC5C,IAAIkI,QAAY,IAAAD,SAAA,CAAUtF,QAAS,CAAAuF,QAAQ,CAAG,EAAA;MAC5CJ,QAAA,CAASI,QAAQ,CAAA,GAAIF,OAAQ,CAAAhI,YAAA,CAAa,SAAS,CAAA;IACrD;EAAA,CACD,CAAA;EAED,MAAMwG,OAA+B,GAAAe,eAAA,CACnCM,aAAA,EACAlB,aAAA,EACAC,kBAAA,CACF;EAEO,OAAA;IACL,GAAGJ,OAAA;IACH,GAAGsB;EAAA,CACL;AACF,CAAA;AAEO,MAAMK,wBAAyC,GAAA;EACpDP,mBAAA;EACAL;AACF,CAAA;"}