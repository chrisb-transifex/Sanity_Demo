import { extractWithPath, arrayToJSONMatchPath } from '@sanity/mutator';
import { htmlToBlocks } from '@sanity/block-tools';
import { Schema } from '@sanity/schema';
import { toHTML } from '@portabletext/to-html';
const reconcileArray = (origArray, translatedArray) => {
  if (translatedArray && translatedArray.some(el => typeof el === "string")) {
    return translatedArray;
  }
  const combined = JSON.parse(JSON.stringify(origArray));
  translatedArray.forEach(block => {
    if (!block._key) {
      return;
    }
    const foundBlockIdx = origArray.findIndex(origBlock => origBlock._key === block._key);
    if (foundBlockIdx < 0) {
      console.warn("This block no longer exists on the original document. Was it removed? ".concat(JSON.stringify(block)));
    } else if (origArray[foundBlockIdx]._type === "block" || origArray[foundBlockIdx]._type === "span") {
      combined[foundBlockIdx] = block;
    } else if (Array.isArray(origArray[foundBlockIdx])) {
      combined[foundBlockIdx] = reconcileArray(origArray[foundBlockIdx], block);
    } else {
      combined[foundBlockIdx] = reconcileObject(origArray[foundBlockIdx], block);
    }
  });
  return combined;
};
const reconcileObject = (origObject, translatedObject) => {
  if (typeof translatedObject !== "object" || !Object.keys(translatedObject).length) {
    return origObject;
  }
  const updatedObj = JSON.parse(JSON.stringify(origObject));
  Object.entries(translatedObject).forEach(_ref => {
    let [key, value] = _ref;
    var _a, _b;
    if (!value || key[0] === "_") {
      return;
    }
    if (typeof value === "string") {
      updatedObj[key] = value;
    } else if (Array.isArray(value)) {
      updatedObj[key] = reconcileArray((_a = origObject[key]) != null ? _a : [], value);
    } else {
      updatedObj[key] = reconcileObject((_b = origObject[key]) != null ? _b : {}, value);
    }
  });
  return updatedObj;
};
const fieldLevelMerge = function (translatedFields, baseDoc, localeId) {
  let baseLang = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : "en";
  const merged = {};
  const metaKeys = ["_rev", "_id", "_type"];
  metaKeys.forEach(metaKey => {
    if (translatedFields[metaKey]) {
      merged[metaKey] = translatedFields[metaKey];
    }
  });
  const originPaths = extractWithPath("..".concat(baseLang), translatedFields);
  originPaths.forEach(match => {
    const origVal = extractWithPath(arrayToJSONMatchPath(match.path), baseDoc)[0].value;
    const translatedVal = extractWithPath(arrayToJSONMatchPath(match.path), translatedFields)[0].value;
    let valToPatch;
    if (typeof translatedVal === "string") {
      valToPatch = translatedVal;
    } else if (Array.isArray(translatedVal) && translatedVal.length) {
      valToPatch = reconcileArray(origVal != null ? origVal : [], translatedVal);
    } else if (typeof translatedVal === "object" && Object.keys(translatedVal).length) {
      valToPatch = reconcileObject(origVal != null ? origVal : {}, translatedVal);
    }
    const destinationPath = [...match.path.slice(0, match.path.length - 1),
    //cut off the "en"
    localeId.replace("-", "_")
    // replace it with our locale
    ];

    merged[arrayToJSONMatchPath(destinationPath)] = valToPatch;
  });
  return merged;
};
const documentLevelMerge = (translatedFields, baseDoc) => {
  return reconcileObject(baseDoc, translatedFields);
};
const BaseDocumentMerger = {
  fieldLevelMerge,
  documentLevelMerge,
  reconcileArray,
  reconcileObject
};
const defaultSchema = Schema.compile({
  name: "default",
  types: [{
    type: "object",
    name: "default",
    fields: [{
      name: "block",
      type: "array",
      of: [{
        type: "block"
      }]
    }]
  }]
});
const blockContentType = defaultSchema.get("default").fields.find(field => field.name === "block").type;
const preprocess = html => {
  const intermediateBlocks = htmlToBlocks("<p>".concat(html, "</p>"), blockContentType);
  if (!intermediateBlocks.length) {
    throw new Error("Error parsing string '".concat(html, "'"));
  }
  return intermediateBlocks[0].children[0].text;
};
const defaultStopTypes = ["reference", "date", "datetime", "file", "geopoint", "image", "number", "crop", "hotspot", "boolean", "url", "color", "code"];
const defaultPortableTextBlockStyles = {
  normal: _ref2 => {
    let {
      value,
      children
    } = _ref2;
    return "<p id=\"".concat(value._key, "\">").concat(children, "</p>");
  },
  blockquote: _ref3 => {
    let {
      value,
      children
    } = _ref3;
    return "<blockquote id=\"".concat(value._key, "\">").concat(children, "</blockquote>");
  },
  h1: _ref4 => {
    let {
      value,
      children
    } = _ref4;
    return "<h1 id=\"".concat(value._key, "\">").concat(children, "</h1>");
  },
  h2: _ref5 => {
    let {
      value,
      children
    } = _ref5;
    return "<h2 id=\"".concat(value._key, "\">").concat(children, "</h2>");
  },
  h3: _ref6 => {
    let {
      value,
      children
    } = _ref6;
    return "<h3 id=\"".concat(value._key, "\">").concat(children, "</h3>");
  },
  h4: _ref7 => {
    let {
      value,
      children
    } = _ref7;
    return "<h4 id=\"".concat(value._key, "\">").concat(children, "</h4>");
  },
  h5: _ref8 => {
    let {
      value,
      children
    } = _ref8;
    return "<h5 id=\"".concat(value._key, "\">").concat(children, "</h5>");
  },
  h6: _ref9 => {
    let {
      value,
      children
    } = _ref9;
    return "<h6 id=\"".concat(value._key, "\">").concat(children, "</h6>");
  }
};
const defaultLists = {
  number: _ref10 => {
    let {
      value,
      children
    } = _ref10;
    return "<ol id=\"".concat(value._key.replace("-parent", ""), "\">").concat(children, "</ol>");
  },
  bullet: _ref11 => {
    let {
      value,
      children
    } = _ref11;
    return "<ul id=\"".concat(value._key.replace("-parent", ""), "\">").concat(children, "</ul>");
  }
};
const defaultListItem = _ref12 => {
  let {
    value,
    children
  } = _ref12;
  const {
    _key,
    level
  } = value;
  return "<li id=\"".concat((_key || "").replace("-parent", ""), "\" data-level=\"").concat(level, "\">").concat(children, "</li>");
};
const unknownBlockFunc = _ref13 => {
  let {
    value,
    children
  } = _ref13;
  return "<p id=\"".concat(value._key, "\" data-type=\"unknown-block-style\" data-style=\"").concat(value.style, "\">").concat(children, "</p>");
};
const customSerializers = {
  unknownType: _ref14 => {
    let {
      value
    } = _ref14;
    return "<div class=\"".concat(value._type, "\"></div>");
  },
  types: {},
  block: defaultPortableTextBlockStyles,
  list: defaultLists,
  listItem: defaultListItem,
  unknownBlockStyle: unknownBlockFunc
};
const customDeserializers = {
  types: {}
};
const customBlockDeserializers = [
//handle undeclared styles
{
  deserialize(el, next) {
    var _a;
    if (!el.hasChildNodes()) {
      return void 0;
    }
    if (el.getAttribute("data-type") !== "unknown-block-style") {
      return void 0;
    }
    const style = (_a = el.getAttribute("data-style")) != null ? _a : "";
    const block = htmlToBlocks(el.outerHTML, blockContentType)[0];
    return {
      ...block,
      style,
      children: next(el.childNodes)
    };
  }
},
//handle list items
{
  deserialize(el, next) {
    var _a, _b;
    if (!el.hasChildNodes()) {
      return void 0;
    }
    if (el.tagName.toLowerCase() !== "li") {
      return void 0;
    }
    const tagsToStyle = {
      ul: "bullet",
      ol: "number"
    };
    const parent = el.parentNode;
    if (!parent || !parent.tagName) {
      return void 0;
    }
    const listItem = tagsToStyle[parent.tagName.toLowerCase()];
    if (!listItem) {
      return void 0;
    }
    const level = el.getAttribute("data-level") && parseInt(el.getAttribute("data-level") || "0", 10);
    const _key = el.id;
    let block = htmlToBlocks(parent.outerHTML, blockContentType)[0];
    const customStyle = (_b = (_a = el.children) == null ? void 0 : _a[0]) == null ? void 0 : _b.getAttribute("data-style");
    const regex = new RegExp(/<("[^"]*"|'[^']*'|[^'">])*>/);
    if (regex.test(el.innerHTML)) {
      const newBlock = htmlToBlocks(el.innerHTML, blockContentType)[0];
      if (newBlock) {
        block = {
          ...block,
          ...newBlock,
          style: customStyle != null ? customStyle : newBlock.style
        };
        if (customStyle) {
          return block;
        }
      }
    }
    return {
      ...block,
      level,
      _key,
      listItem,
      children: next(el.childNodes)
    };
  }
}];
const META_FIELDS$1 = ["_key", "_type", "_id"];
const languageObjectFieldFilter = (obj, baseLang) => {
  const filterToLangField = childObj => {
    const filteredObj = {};
    filteredObj[baseLang] = childObj[baseLang];
    META_FIELDS$1.forEach(field => {
      if (childObj[field]) {
        filteredObj[field] = childObj[field];
      }
    });
    return filteredObj;
  };
  const findBaseLang = childObj => {
    const filteredObj = {};
    META_FIELDS$1.forEach(field => {
      if (childObj[field]) {
        filteredObj[field] = childObj[field];
      }
    });
    for (const key in childObj) {
      if (childObj.hasOwnProperty(key)) {
        const value = childObj[key];
        if (value.hasOwnProperty(baseLang)) {
          filteredObj[key] = filterToLangField(value);
        } else if (Array.isArray(value) && value.length && typeof value[0] === "object") {
          const validLangObjects = value.reduce((validArr, objInArray) => {
            if (objInArray._type === "block") {
              validArr.push(objInArray);
            } else if (objInArray.hasOwnProperty(baseLang)) {
              validArr.push(filterToLangField(objInArray));
            } else {
              const filtered = findBaseLang(objInArray);
              const nonMetaFields = Object.keys(filtered).filter(objInArrayKey => META_FIELDS$1.indexOf(objInArrayKey) === -1);
              if (nonMetaFields.length) {
                validArr.push(filtered);
              }
            }
            return validArr;
          }, []);
          if (validLangObjects.length) {
            filteredObj[key] = validLangObjects;
          }
        } else if (typeof value === "object") {
          const nestedLangObj = findBaseLang(value);
          const nonMetaFields = Object.keys(nestedLangObj).filter(nestedObjKey => META_FIELDS$1.indexOf(nestedObjKey) === -1);
          if (nonMetaFields.length) {
            filteredObj[key] = nestedLangObj;
          }
        }
      }
    }
    return filteredObj;
  };
  return findBaseLang(obj);
};
const fieldFilter = (obj, objFields, stopTypes) => {
  var _a;
  const filteredObj = {
    _type: obj._type
  };
  const fieldFilterFunc = field => {
    if (field.localize === false) {
      return false;
    } else if (field.type === "string" || field.type === "text") {
      return true;
    } else if (Array.isArray(obj[field.name])) {
      return true;
    } else if (!stopTypes.includes(field.type)) {
      return true;
    }
    return false;
  };
  const validFields = [...META_FIELDS$1, ...((_a = objFields == null ? void 0 : objFields.filter(fieldFilterFunc)) == null ? void 0 : _a.map(field => field.name))];
  validFields.forEach(field => {
    if (obj[field]) {
      filteredObj[field] = obj[field];
    }
  });
  return filteredObj;
};
const META_FIELDS = ["_key", "_type", "_id", "_weak"];
const BaseDocumentSerializer = schemas => {
  const getSchema = name => {
    var _a;
    return (_a = schemas == null ? void 0 : schemas._original) == null ? void 0 : _a.types.find(s => s.name === name);
  };
  const serializeObject = (obj, stopTypes, serializers) => {
    if (stopTypes.includes(obj._type)) {
      return "";
    }
    const hasSerializer = serializers.types && Object.keys(serializers.types).includes(obj._type);
    if (hasSerializer) {
      return toHTML([obj], {
        components: serializers
      });
    }
    if (obj._type === "span" || obj._type === "block") {
      return toHTML(obj, {
        components: serializers
      });
    }
    let fieldNames = Object.keys(obj).filter(key => key !== "_type");
    const schema = getSchema(obj._type);
    if (schema && schema.fields) {
      fieldNames = schema.fields.map(field => field.name).filter(schemaKey => Object.keys(obj).includes(schemaKey));
    }
    if (typeof obj === "object" && !obj._type) {
      obj._type = "";
    }
    const newSerializationMethods = {};
    const tempType = "".concat(obj._type, "__temp_type__").concat(Math.random().toString(36).substring(7));
    const objToSerialize = {
      _type: tempType
    };
    META_FIELDS.filter(f => f !== "_type").forEach(field => {
      objToSerialize[field] = obj[field];
    });
    let innerHTML = "";
    fieldNames.forEach(fieldName => {
      let htmlField = "";
      if (!META_FIELDS.includes(fieldName)) {
        const value = obj[fieldName];
        if (typeof value === "string") {
          const htmlRegex = new RegExp(/<("[^"]*"|'[^']*'|[^'">])*>/);
          if (htmlRegex.test(value)) {
            htmlField = value;
          } else {
            htmlField = "<span class=\"".concat(fieldName, "\">").concat(value, "</span>");
          }
        } else if (Array.isArray(value)) {
          htmlField = serializeArray(value, fieldName, stopTypes, {
            ...serializers,
            types: {
              ...serializers.types
            }
          });
        } else {
          const embeddedObject = value;
          const embeddedObjectSchema = getSchema(embeddedObject._type);
          let toTranslate = embeddedObject;
          if (embeddedObjectSchema && embeddedObjectSchema.fields) {
            toTranslate = fieldFilter(toTranslate, embeddedObjectSchema.fields, stopTypes);
          }
          const objHTML = serializeObject(toTranslate, stopTypes, {
            ...serializers,
            types: {
              ...serializers.types
            }
          });
          htmlField = "<div class=\"".concat(fieldName, "\" data-level=\"field\">").concat(objHTML, "</div>");
        }
        innerHTML += htmlField;
      }
    });
    if (!innerHTML) {
      return "";
    }
    newSerializationMethods[tempType] = _ref15 => {
      let {
        value
      } = _ref15;
      var _a;
      let div = "<div class=\"".concat(value._type.split("__temp_type__")[0], "\"");
      if (value._key || value._id) {
        div += "id=\"".concat((_a = value._key) != null ? _a : value._id, "\"");
      }
      return [div, " data-type=\"object\">".concat(innerHTML, "</div>")].join("");
    };
    let serializedBlock = "";
    try {
      serializedBlock = toHTML(objToSerialize, {
        components: {
          ...serializers,
          types: {
            ...serializers.types,
            ...newSerializationMethods
          }
        }
      });
    } catch (err) {
      console.warn("Had issues serializing block of type \"".concat(obj._type, "\". Please specify a serialization method for this block in your serialization config. Received error: ").concat(err));
    }
    return serializedBlock;
  };
  const serializeArray = (fieldContent, fieldName, stopTypes, serializers) => {
    const validBlocks = fieldContent.filter(block => !stopTypes.includes(block._type));
    const filteredBlocks = validBlocks.map(block => {
      const schema = getSchema(block._type);
      if (schema && schema.fields) {
        return fieldFilter(block, schema.fields, stopTypes);
      }
      return block;
    });
    const output = filteredBlocks.map(obj => {
      if (typeof obj === "string") {
        return "<span>".concat(obj, "</span>");
      }
      return serializeObject(obj, stopTypes, serializers);
    });
    return "<div class=\"".concat(fieldName, "\" data-type=\"array\">").concat(output.join(""), "</div>");
  };
  const serializeDocument = function (doc) {
    let translationLevel = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : "document";
    let baseLang = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : "en";
    let stopTypes = arguments.length > 3 && arguments[3] !== undefined ? arguments[3] : defaultStopTypes;
    let serializers = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : customSerializers;
    const schema = getSchema(doc._type);
    let filteredObj = {};
    if (translationLevel === "field") {
      filteredObj = languageObjectFieldFilter(doc, baseLang);
    } else {
      filteredObj = fieldFilter(doc, schema.fields, stopTypes);
    }
    const serializedFields = {};
    for (const key in filteredObj) {
      if (filteredObj.hasOwnProperty(key) === false) continue;
      const value = filteredObj[key];
      if (typeof value === "string") {
        serializedFields[key] = value;
      } else if (Array.isArray(value)) {
        serializedFields[key] = serializeArray(value, key, stopTypes, serializers);
      } else if (value && !stopTypes.find(stopType => stopType == (value == null ? void 0 : value._type))) {
        const serialized = serializeObject(value, stopTypes, serializers);
        serializedFields[key] = "<div class=\"".concat(key, "\" data-level='field'>").concat(serialized, "</div>");
      }
    }
    const rawHTMLBody = document.createElement("body");
    rawHTMLBody.innerHTML = serializeObject(serializedFields, stopTypes, serializers);
    const rawHTMLHead = document.createElement("head");
    const metaFields = ["_id", "_type", "_rev"];
    metaFields.forEach(field => {
      const metaEl = document.createElement("meta");
      metaEl.setAttribute("name", field);
      metaEl.setAttribute("content", doc[field]);
      rawHTMLHead.appendChild(metaEl);
    });
    const versionMeta = document.createElement("meta");
    versionMeta.setAttribute("name", "version");
    versionMeta.setAttribute("content", "3");
    rawHTMLHead.appendChild(versionMeta);
    const rawHTML = document.createElement("html");
    rawHTML.appendChild(rawHTMLHead);
    rawHTML.appendChild(rawHTMLBody);
    return {
      name: doc._id,
      content: rawHTML.outerHTML
    };
  };
  return {
    serializeDocument,
    fieldFilter,
    languageObjectFieldFilter,
    serializeArray,
    serializeObject
  };
};
const deserializeArray = function (arrayHTML) {
  let deserializers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : customDeserializers;
  let blockDeserializers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : customBlockDeserializers;
  const output = [];
  const children = Array.from(arrayHTML.children);
  children.forEach(child => {
    var _a;
    let deserializedObject;
    try {
      if (((_a = child.tagName) == null ? void 0 : _a.toLowerCase()) === "span") {
        deserializedObject = preprocess(child.innerHTML);
      } else if (child.className || child.getAttribute("data-type") === "object") {
        deserializedObject = deserializeObject(child, deserializers, blockDeserializers);
        deserializedObject._key = child.id;
      } else {
        deserializedObject = htmlToBlocks(child.outerHTML, blockContentType, {
          rules: blockDeserializers
        })[0];
        deserializedObject._key = child.id;
      }
    } catch (e) {
      console.debug("Tried to deserialize block: ".concat(child.outerHTML, " in an array but failed to identify it! Error: ").concat(e));
    }
    output.push(deserializedObject);
  });
  return output;
};
const deserializeObject = function (objectHTML) {
  let deserializers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : customDeserializers;
  let blockDeserializers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : customBlockDeserializers;
  const deserialize = deserializers.types[objectHTML.className];
  if (deserialize) {
    return deserialize(objectHTML);
  }
  const output = {};
  if (objectHTML.className) {
    output._type = objectHTML.className;
  }
  const children = Array.from(objectHTML.children);
  children.forEach(child => {
    var _a;
    if (((_a = child.tagName) == null ? void 0 : _a.toLowerCase()) === "span") {
      output[child.className] = preprocess(child.innerHTML);
    } else if (child.getAttribute("data-level") === "field") {
      const deserialized = deserializeHTML(child.outerHTML, deserializers, blockDeserializers);
      if (deserialized && Object.keys(deserialized).length) {
        output[child.className] = deserialized;
      } else {
        console.debug("Deserializer: Skipping empty or unreadable HTML: ".concat(child.outerHTML));
      }
    } else if (child.getAttribute("data-type") === "array") {
      output[child.className] = deserializeArray(child, deserializers, blockDeserializers);
    }
  });
  return output;
};
const deserializeHTML = (html, deserializers, blockDeserializers) => {
  let HTMLnode = new DOMParser().parseFromString(html, "text/html").body.children[0];
  if ((HTMLnode == null ? void 0 : HTMLnode.getAttribute("data-level")) === "field") {
    HTMLnode = HTMLnode.children[0];
  }
  if (!HTMLnode) {
    return {};
  }
  let output;
  const deserialize = deserializers.types[HTMLnode.className];
  if (deserialize) {
    output = deserialize(HTMLnode);
  } else if (HTMLnode.getAttribute("data-type") === "object") {
    output = deserializeObject(HTMLnode, deserializers, blockDeserializers);
  } else if (HTMLnode.getAttribute("data-type") === "array") {
    output = deserializeArray(HTMLnode, deserializers, blockDeserializers);
  } else {
    output = {};
    console.debug("Tried to deserialize block ".concat(HTMLnode.outerHTML, " but failed to identify it!"));
  }
  return output;
};
const deserializeDocument = function (serializedDoc) {
  let deserializers = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : customDeserializers;
  let blockDeserializers = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : customBlockDeserializers;
  const metadata = {};
  const head = new DOMParser().parseFromString(serializedDoc, "text/html").head;
  Array.from(head.children).forEach(metaTag => {
    const validTags = ["_id", "_rev", "_type"];
    const metaName = metaTag.getAttribute("name");
    if (metaName && validTags.includes(metaName)) {
      metadata[metaName] = metaTag.getAttribute("content");
    }
  });
  const content = deserializeHTML(serializedDoc, deserializers, blockDeserializers);
  return {
    ...content,
    ...metadata
  };
};
const BaseDocumentDeserializer = {
  deserializeDocument,
  deserializeHTML
};
export { BaseDocumentDeserializer, BaseDocumentMerger, BaseDocumentSerializer, customBlockDeserializers, customSerializers, defaultStopTypes };
//# sourceMappingURL=index.esm.js.map
